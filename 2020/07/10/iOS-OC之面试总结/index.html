<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>iOS-OC之面试总结 | 张建的博客</title><meta name="description" content="常见面试题swift面试题Swift中struct和class有什么区别？ struct是值引用，更轻量，存放于栈区。 class是类型引用，存放于堆区。 struct无法继承，class可继承。  Swift和OC有什么区别？ 怎么理解面向协议编程？ 面向对象是以对象的视角观察整体结构，万物皆为对象 面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。  OC面试"><meta name="keywords" content="iOS-OC"><meta name="author" content="小J,13718004742@163.com"><meta name="copyright" content="小J"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/13718004742.github.io/img/favicon.png"><link rel="canonical" href="https://www.bboyzj.cn/2020/07/10/iOS-OC%E4%B9%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="iOS-OC之面试总结"><meta property="og:url" content="https://www.bboyzj.cn/2020/07/10/iOS-OC%E4%B9%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="张建的博客"><meta property="og:description" content="常见面试题swift面试题Swift中struct和class有什么区别？ struct是值引用，更轻量，存放于栈区。 class是类型引用，存放于堆区。 struct无法继承，class可继承。  Swift和OC有什么区别？ 怎么理解面向协议编程？ 面向对象是以对象的视角观察整体结构，万物皆为对象 面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。  OC面试"><meta property="og:image" content="https://user-images.githubusercontent.com/25925248/89222506-be0f2480-d607-11ea-823f-aed914e3b27e.jpg"><meta property="article:published_time" content="2020-07-10T03:47:39.000Z"><meta property="article:modified_time" content="2020-08-25T04:53:22.104Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/13718004742.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/13718004742.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"limitCount":50,"languages":{"author":"作者: 小J","link":"链接: ","source":"来源: 张建的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-25 12:53:22'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/13718004742.github.io/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/13718004742.github.io/archives/"><div class="headline">文章</div><div class="length_num">76</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/13718004742.github.io/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/13718004742.github.io/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/13718004742.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/13718004742.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/13718004742.github.io/movies/"><i class="fa-fw fas fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/link/"><i class="fa-fw fa fa-users"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">常见面试题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#swift%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">swift面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift%E4%B8%ADstruct%E5%92%8Cclass%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Swift中struct和class有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift%E5%92%8COC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Swift和OC有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">怎么理解面向协议编程？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OC%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">OC面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS-%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">iOS 关键词有哪些？各有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8Batomic%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">讲一下atomic的实现机制？为什么不能保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import%E8%B7%9F-include-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C-class%E5%91%A2%EF%BC%8C-import-lt-gt-%E8%B7%9F-import%E2%80%9D%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">iOS中几种常见的设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88UI%E5%BF%85%E9%A1%BB%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0"><span class="toc-number">3.5.</span> <span class="toc-text">为什么UI必须在主线程刷新?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">数据持久化方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alloc%E3%80%81init%E3%80%81new%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">alloc、init、new的区别和原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">常见的状态码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property-%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fivar%E3%80%81getter%E3%80%81setter-%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%99%E4%B8%AA%E7%B1%BB%E4%B8%AD%E7%9A%84"><span class="toc-number">3.9.</span> <span class="toc-text">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frame-%E5%92%8C-bounds-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">frame 和 bounds 有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Objective-C%E7%9A%84%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%EF%BC%9FCategory%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%87%8D%E5%86%99%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E7%94%A8%E7%BB%A7%E6%89%BF%E5%A5%BD%E8%BF%98%E6%98%AF%E5%88%86%E7%B1%BB%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synthesize-%E5%92%8C-dynamic-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">@synthesize 和 @dynamic 分别有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Objective-C-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%9C%8B%E6%B3%95%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">Objective-C 如何对内存管理的，说说你的看法和解决方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%94%A8%E8%BF%87%E9%82%A3%E4%B8%AA%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">非对称加密和对称加密有哪些？用过那个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Method%E3%80%81SEL%E3%80%81IMP%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">Method、SEL、IMP关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9FUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">3.16.</span> <span class="toc-text">UIViewController生命周期UIView的生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSSet%E5%92%8CNSArray%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">NSSet和NSArray的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E2%BE%BC%E6%80%A7%E8%83%BD%E7%9A%84%E7%BB%99-UIImageView-%E5%8A%A0%E4%B8%AA%E5%9C%86%E2%BB%86"><span class="toc-number">3.18.</span> <span class="toc-text">如何⾼性能的给 UIImageView 加个圆⻆?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BF%90%E2%BE%8F%E7%BB%93%E6%9E%9C%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">3.19.</span> <span class="toc-text">以下代码运⾏结果如何？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-barrier-async%EF%BC%88%E6%A0%85%E6%A0%8F%E5%87%BD%E6%95%B0%EF%BC%89%E7%9A%84%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">dispatch_barrier_async（栅栏函数）的作⽤是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%8B%A5%E2%BC%B2%E4%B8%AAurl%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%A4%9A%E5%BC%A0%E5%9B%BE%E2%BD%9A%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%83%BD%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E5%90%88%E6%88%90%E2%BC%80%E5%BC%A0%E6%95%B4%E5%9B%BE%EF%BC%9FGCD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.21.</span> <span class="toc-text">根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E5%9B%9E%E8%B0%83"><span class="toc-number">3.22.</span> <span class="toc-text">10个网络请求顺序回调?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E2%BC%80%E8%88%AC%E6%98%AF%E6%80%8E%E4%B9%88%E2%BD%A4nstruments%E7%9A%84%EF%BC%9FInstruments%E2%BE%A5%E2%BE%AF%E2%BC%AF%E5%85%B7%E5%BE%88%E5%A4%9A%EF%BC%8C%E5%B8%B8%E2%BD%A4%EF%BC%9A"><span class="toc-number">3.23.</span> <span class="toc-text">你⼀般是怎么⽤nstruments的？Instruments⾥⾯⼯具很多，常⽤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isKindOfClass%E3%80%81isMemberOfClass%E3%80%81selector%E4%BD%9C%E2%BD%A4%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.24.</span> <span class="toc-text">isKindOfClass、isMemberOfClass、selector作⽤分别是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84-public%EF%BC%8C-protected%EF%BC%8C-private%EF%BC%8C-package-%E5%A3%B0%E6%98%8E%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-number">3.25.</span> <span class="toc-text">类变量的 @public，@protected，@private，@package 声明各有什么含义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E5%90%A6%E6%8E%A5%E8%A7%A6%E8%BF%87OC%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F%E7%AE%80%E5%8D%95%E8%81%8A%E2%BC%80%E4%B8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E2%BD%A4%EF%BC%9F"><span class="toc-number">3.26.</span> <span class="toc-text">你是否接触过OC中的反射机制？简单聊⼀下概念和使⽤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-weak-%E5%B1%9E%E6%80%A7-weak%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E7%BD%AEnil%E7%9A%84%EF%BC%9F"><span class="toc-number">3.27.</span> <span class="toc-text">runtime 如何实现 weak 属性?weak属性如何自动置nil的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSHashTable%E5%92%8CNSMapTable%EF%BC%9F"><span class="toc-number">3.28.</span> <span class="toc-text">NSHashTable和NSMapTable？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E7%94%A8copy%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99%E5%B8%A6copy%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84setter%EF%BC%9F"><span class="toc-number">3.29.</span> <span class="toc-text">如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAobjc%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%9F%E4%B8%80%E4%B8%AAobjc%E5%AF%B9%E8%B1%A1%E7%9A%84isa%E7%9A%84%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.30.</span> <span class="toc-text">一个objc对象如何进行内存布局？一个objc对象的isa的指针指向什么？有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objc-%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.31.</span> <span class="toc-text">objc 中的类方法和实例方法有什么本质区别和联系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objc-msgForward%E5%87%BD%E6%95%B0%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E5%AE%83%E5%B0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.32.</span> <span class="toc-text">_objc_msgForward函数是做什么的，直接调用它将会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LLDB%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.33.</span> <span class="toc-text">LLDB常用的调试命令有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0tableView%E5%8D%A1%E9%A1%BF%E5%98%9B%EF%BC%9F%E4%BC%9A%E9%80%A0%E6%88%90%E5%8D%A1%E9%A1%BF%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%A4%A7%E8%87%B4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.34.</span> <span class="toc-text">遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？如何解决卡顿问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%9FCPU%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%9FGPU%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.35.</span> <span class="toc-text">什么是离屏渲染？CPU离屏渲染？GPU屏幕渲染类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%93%BE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%9A%84%EF%BC%9F"><span class="toc-number">3.36.</span> <span class="toc-text">事件响应链是如何传递的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.37.</span> <span class="toc-text">静态库和动态库的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSCoding%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">3.38.</span> <span class="toc-text">NSCoding协议是干什么用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9FCategory-%E5%9C%A8%E7%BC%96%E8%AF%91%E8%BF%87%E5%90%8E%EF%BC%8C%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E6%9C%BA%E4%B8%8E%E5%8E%9F%E6%9C%89%E7%9A%84%E7%B1%BB%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%80%E8%B5%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.39.</span> <span class="toc-text">Category 的实现原理？Category 在编译过后，是在什么时机与原有的类合并到一起的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%86%99%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.40.</span> <span class="toc-text">用伪代码写一个线程安全的单例模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dealloc-%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.41.</span> <span class="toc-text">Dealloc 调用流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">循环引用的几种情况和解决方式？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">数组和链表的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#category%E8%83%BD%E5%90%A6%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E8%83%BD%E5%90%A6%E6%B7%BB%E5%8A%A0%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">category能否添加属性，为什么？能否添加实例变量，为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ARC%E6%96%B9%E6%A1%88%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%81%9A%E7%9A%84%E9%9A%90%E5%A3%AB%E6%B7%BB%E5%8A%A0release%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">ARC方案的原理是什么？它是在什么时候做的隐士添加release？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%E5%86%85%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%9F%E5%AE%83%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E4%BC%9A%E6%94%BE%E5%85%A5%E5%88%B0AutoreleasePool%E4%B8%AD%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">AutoreleasePool的实现机制是什么？实现原理是什么？他是什么时候释放内部对象的？它内部的数据结构是什么样子的？哪些对象会放入到AutoreleasePool中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BD%93%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E9%83%A8hash%E8%A1%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">weak的实现原理是什么？当引用对象销毁时，它是如何管理内部hash表的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#runLoop"><span class="toc-number">8.</span> <span class="toc-text">runLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">RunLoop是什么，有什么作用，原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">RunLoop模式的原理和使用注意点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9FRunloop%E7%9A%84mode-Runloop%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%94%A8Runloop%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">可以用Runloop实现什么功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSTimer%E5%92%8CRunLoop%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">NSTimer和RunLoop的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSTimer%E5%87%86%E7%A1%AE%E5%90%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%87%86%E7%A1%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%87%86%E7%A1%AE%E7%9A%84timer%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">NSTimer准确吗，如果不准确，如何设计一个准确的timer？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TableView-ScrollView-CollectionView%E6%BB%9A%E5%8A%A8%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88NSTimer%E4%BC%9A%E5%81%9C%E6%AD%A2%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">TableView&#x2F;ScrollView&#x2F;CollectionView滚动时为什么NSTimer会停止？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CNSTimer%E5%9C%A8%E5%88%86%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">如果NSTimer在分线程中创建，会发生什么，应该注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%B8%8B%E8%BD%BD%E5%BE%88%E5%A4%9A%E5%9B%BE%E7%89%87-%E5%A6%82%E6%9E%9C%E5%A4%B1%E8%B4%A5%E4%BA%86-%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-%E8%AF%B7%E7%BB%93%E5%90%88RunLoop%E6%9D%A5%E8%B0%88%E8%B0%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.9.</span> <span class="toc-text">在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%B0%B1%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">8.10.</span> <span class="toc-text">如果程序启动就需要执行一个耗时操作，你会怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%97%B6%EF%BC%8Crunloop%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%B0%B1%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">8.11.</span> <span class="toc-text">程序启动时，runloop是如何工作的？如果程序启动就需要执行一个耗时操作，你会怎么做？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%B8%B8%E9%97%AE%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">经常问的面试题：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84runloop%E6%98%AF%E5%BC%80%E5%90%AF%E7%9A%84%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">为什么只有主线程的runloop是开启的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">为什么只在主线程刷新UI？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PerformSelector%E5%92%8Crunloop%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">PerformSelector和runloop的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB"><span class="toc-number">9.4.</span> <span class="toc-text">如何使线程保活</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Block"><span class="toc-number">10.</span> <span class="toc-text">Block</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBlock%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">什么是Block？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FBlock%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F-block%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">Block的分类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BD%BF%E7%94%A8block%E6%97%B6%E5%A4%96%E9%9D%A2%E6%98%AFweak-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAweakSelf%EF%BC%8C%E8%BF%98%E8%A6%81%E5%9C%A8block%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8strong%E5%86%8D%E6%8C%81%E6%9C%89%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-block%E8%83%BD%E5%A4%9F%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">为什么__block能够修改外部变量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.6.</span> <span class="toc-text">__block修饰变量和对象的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block%E7%94%A8copy%E4%BF%AE%E9%A5%B0%E8%BF%98%E6%98%AFstrong%E4%BF%AE%E9%A5%B0%EF%BC%9F"><span class="toc-number">10.7.</span> <span class="toc-text">Block用copy修饰还是strong修饰？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block%E5%8F%98%E9%87%8F%E6%88%AA%E8%8E%B7%EF%BC%9F"><span class="toc-number">10.8.</span> <span class="toc-text">Block变量截获？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assign-%E5%92%8C-weak%E9%83%BD%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">10.9.</span> <span class="toc-text">assign 和 weak都是弱引用声明类型，最大的区别是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block%E5%92%8C-weak%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.10.</span> <span class="toc-text">__Block和__weak的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block%E5%92%8Cdelegate%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.11.</span> <span class="toc-text">block和delegate区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">10.12.</span> <span class="toc-text">以下代码是否可以正确执行？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KVO"><span class="toc-number">11.</span> <span class="toc-text">KVO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F-KVO%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">KVO的实现原理？(KVO的本质是什么？)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="toc-number">11.2.</span> <span class="toc-text">KVO监听方法可以在子线程吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E5%85%B3%E9%97%ADkvo"><span class="toc-number">11.3.</span> <span class="toc-text">如何手动关闭kvo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91KVO%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">如何手动触发KVO？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87KVC%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E4%BC%9A%E8%A7%A6%E5%8F%91KVO%E4%B9%88-%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E6%88%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E5%91%A2%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">通过KVC修改属性会触发KVO么?如果修改成变量的值呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8kvo%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%8C%E6%80%8E%E4%B9%88%E9%98%B2%E6%8A%A4%E5%B4%A9%E6%BA%83"><span class="toc-number">11.6.</span> <span class="toc-text">哪些情况下使用kvo会崩溃，怎么防护崩溃</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#runtime"><span class="toc-number">12.</span> <span class="toc-text">runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3Objective-C%E6%98%AF%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E8%A8%80%E3%80%82"><span class="toc-number">12.1.</span> <span class="toc-text">怎么理解Objective-C是动态运行时语言。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-weak-%E5%B1%9E%E6%80%A7"><span class="toc-number">12.2.</span> <span class="toc-text">Runtime 如何实现 weak 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">下面的代码输出什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8BObjective-C%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">简述下Objective-C中调用方法的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87selector%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84IMP%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">runtime如何通过selector找到对应的IMP地址？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">super的本质？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isa%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AF%B9%E8%B1%A1%E7%9A%84isa%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C%EF%BC%9Fisa%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-number">12.8.</span> <span class="toc-text">runtime具体应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class-copyIvarList-amp-class-copyPropertyList%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.9.</span> <span class="toc-text">class_copyIvarList &amp; class_copyPropertyList区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class-rw-t-%E5%92%8C-class-ro-t-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.10.</span> <span class="toc-text">class_rw_t 和 class_ro_t 的区别？**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#category-amp-extension%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%83%BD%E7%BB%99NSObject%E6%B7%BB%E5%8A%A0Extension%E5%90%97%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">12.11.</span> <span class="toc-text">category &amp; extension区别，能给NSObject添加Extension吗，结果如何？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1metaclass"><span class="toc-number">12.12.</span> <span class="toc-text">为什么要设计metaclass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84crash%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">12.13.</span> <span class="toc-text">我们常见的crash有哪些？如何处理？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">13.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">14.</span> <span class="toc-text">协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89-property%E4%B9%88%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">协议中可以定义@property么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#category%E5%92%8Cextension%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%88%86%E4%B8%A4%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">category和extension的作用？分两类和扩展的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Category%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8ACategory%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E8%83%BD%E5%8A%A0%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">15.1.</span> <span class="toc-text">Category的实现原理，以及Category为什么只能加方法不能加属性?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category%E4%B8%AD%E6%9C%89load%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9Fload%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9Fload-%E6%96%B9%E6%B3%95%E8%83%BD%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%EF%BC%9F"><span class="toc-number">15.2.</span> <span class="toc-text">Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load%E3%80%81initialize%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E5%9C%A8category%E9%87%8D%E5%86%99%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E8%B0%83%E7%94%A8%E7%9A%84%E6%AC%A1%E5%BA%8F%EF%BC%9F"><span class="toc-number">15.3.</span> <span class="toc-text">load、initialize的区别，以及它们在category重写的时候的调用的次序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">15.4.</span> <span class="toc-text">普通方法的调用顺序?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E6%AF%94"><span class="toc-number">16.1.</span> <span class="toc-text">iOS开发中有多少类型的线程？分别对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%9F%E5%88%97%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BE%9B%E5%93%AA%E4%BA%9B%E9%98%9F%E5%88%97"><span class="toc-number">16.2.</span> <span class="toc-text">GCD有哪些队列，默认提供哪些队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD%E4%B8%AD%E7%9A%84Block%E6%98%AF%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%8A%EF%BC%9F"><span class="toc-number">16.3.</span> <span class="toc-text">GCD中的Block是在堆上还是栈上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95api"><span class="toc-number">16.4.</span> <span class="toc-text">GCD有哪些方法api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD%E4%B8%BB%E7%BA%BF%E7%A8%8B-amp-%E4%B8%BB%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">16.5.</span> <span class="toc-text">GCD主线程 &amp; 主队列的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E6%96%B9%E5%BC%8F%E5%B0%B1%E8%AF%B4%E5%A4%9A%E5%B0%91"><span class="toc-number">16.6.</span> <span class="toc-text">如何实现同步，有多少方式就说多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch-once%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">16.7.</span> <span class="toc-text">dispatch_once实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-number">16.8.</span> <span class="toc-text">什么情况下会死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%94%81%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.9.</span> <span class="toc-text">有哪些类型的线程锁，分别介绍下作用和使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSOperationQueue%E4%B8%AD%E7%9A%84maxConcurrentOperationCount%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">16.10.</span> <span class="toc-text">NSOperationQueue中的maxConcurrentOperationCount默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSTimer%E3%80%81CADisplayLink%E3%80%81dispatch-source-t-%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="toc-number">16.11.</span> <span class="toc-text">NSTimer、CADisplayLink、dispatch_source_t 的优劣</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89a%EF%BC%8Cb%EF%BC%8Cc3%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%8C%EF%BC%8C%E5%9C%A8a%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8Cb%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8Cb%E5%AE%8C%E6%88%90%E5%90%8Ec%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8c%E7%BB%93%E6%9D%9F%E6%97%B6%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E9%80%9A%E7%9F%A5%E3%80%82%E8%BF%99%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BE%9D%E8%B5%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">16.12.</span> <span class="toc-text">有a，b，c3个网络请求，，在a请求完成后，b发起请求，b完成后c发起请求，在c结束时获得一个通知。这相当于多线程同步以及依赖，怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">16.13.</span> <span class="toc-text">多线程在项目中的应用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD%E3%80%81NSOperation%E5%92%8CNSThread%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">16.14.</span> <span class="toc-text">GCD、NSOperation和NSThread的区别和特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">16.15.</span> <span class="toc-text">单例的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy%E5%92%8Cstrong%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.16.</span> <span class="toc-text">copy和strong的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notification%E9%80%9A%E7%9F%A5"><span class="toc-number">16.17.</span> <span class="toc-text">Notification通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delegate%E5%92%8CBlock%E5%8C%BA%E5%88%AB"><span class="toc-number">16.18.</span> <span class="toc-text">Delegate和Block区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">16.19.</span> <span class="toc-text">计时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIView%E5%92%8CCALayer"><span class="toc-number">16.20.</span> <span class="toc-text">UIView和CALayer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">16.21.</span> <span class="toc-text">内存管理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARC-%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8Cautorelease-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%EF%BC%9F%E5%9B%9E%E5%88%B0%E6%88%91%E4%BB%AC%E6%9C%80%E5%88%9D%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%9C%A8ARC%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8Cautorelease%E5%AF%B9%E8%B1%A1%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE%EF%BC%9F%E6%88%91%E4%BB%AC%E5%B0%B1%E5%88%86%E7%B3%BB%E7%BB%9F%E5%B9%B2%E9%A2%84%E9%87%8A%E6%94%BE%E5%92%8C%E6%89%8B%E5%8A%A8%E5%B9%B2%E9%A2%84%E9%87%8A%E6%94%BE%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E5%9B%9E%E7%AD%94%E3%80%82"><span class="toc-number">16.22.</span> <span class="toc-text">ARC 环境下，autorelease 对象在什么时候释放？回到我们最初的面试题，在ARC环境下，autorelease对象在什么时候释放？我们就分系统干预释放和手动干预释放两种情况回答。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDWebImage"><span class="toc-number">17.</span> <span class="toc-text">SDWebImage</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AFNetworking"><span class="toc-number">18.</span> <span class="toc-text">AFNetworking</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MJEetension"><span class="toc-number">18.1.</span> <span class="toc-text">MJEetension</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MJRefresh"><span class="toc-number">18.2.</span> <span class="toc-text">MJRefresh</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A10%E9%98%B6%E6%A5%BC%E6%A2%AF%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%8F%AA%E8%83%BD%E8%B5%B0%E4%B8%80%E9%98%B6%E6%88%96%E4%BA%AE%E9%98%B6%E6%88%96%E4%B8%89%E9%98%B6%EF%BC%8C%E9%97%AE%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E8%B5%B0%E6%B3%95%EF%BC%9F"><span class="toc-number">19.1.</span> <span class="toc-text">问题：10阶楼梯，每次只能走一阶或亮阶或三阶，问有多少种走法？</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://user-images.githubusercontent.com/25925248/89222506-be0f2480-d607-11ea-823f-aed914e3b27e.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/13718004742.github.io/">张建的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/13718004742.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/13718004742.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/13718004742.github.io/movies/"><i class="fa-fw fas fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/link/"><i class="fa-fw fa fa-users"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/13718004742.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">iOS-OC之面试总结</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-10T03:47:39.000Z" title="发表于 2020-07-10 11:47:39">2020-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-25T04:53:22.104Z" title="更新于 2020-08-25 12:53:22">2020-08-25</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h1 id="swift面试题"><a href="#swift面试题" class="headerlink" title="swift面试题"></a>swift面试题</h1><h2 id="Swift中struct和class有什么区别？"><a href="#Swift中struct和class有什么区别？" class="headerlink" title="Swift中struct和class有什么区别？"></a>Swift中struct和class有什么区别？</h2><ul>
<li>struct是值引用，更轻量，存放于栈区。</li>
<li>class是类型引用，存放于堆区。</li>
<li>struct无法继承，class可继承。</li>
</ul>
<h2 id="Swift和OC有什么区别？"><a href="#Swift和OC有什么区别？" class="headerlink" title="Swift和OC有什么区别？"></a>Swift和OC有什么区别？</h2><p><img src= "/13718004742.github.io/img/loading.gif" data-lazy-src="https://user-images.githubusercontent.com/25925248/90952034-c7ffa700-e492-11ea-8527-9954644b678b.png"></p>
<h2 id="怎么理解面向协议编程？"><a href="#怎么理解面向协议编程？" class="headerlink" title="怎么理解面向协议编程？"></a>怎么理解面向协议编程？</h2><ul>
<li>面向对象是以对象的视角观察整体结构，万物皆为对象</li>
<li>面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。</li>
</ul>
<h1 id="OC面试题"><a href="#OC面试题" class="headerlink" title="OC面试题"></a>OC面试题</h1><h2 id="iOS-关键词有哪些？各有什么作用？"><a href="#iOS-关键词有哪些？各有什么作用？" class="headerlink" title="iOS 关键词有哪些？各有什么作用？"></a>iOS 关键词有哪些？各有什么作用？</h2><p>1.readwrite：是可读可写特性，同时生成get方法和set方法的声明和实现<br>2.readonly：只读特性，只会生成get方法的声明和实现；不希望属性在类外改变<br>3.assign：主要用于修饰基本数据类型<br>4.retain：表示持有特性，传入参数的retaincount会+1,用于MRC<br>5.copy：用于修饰有可变类型的不可变对象NSString/NSArray/NSDictionary<br>6.nonatomic：非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic<br>7.strong：strong修饰符表示指向并持有该对象，其修饰的对象引用计数会+1，该对象只要引用计数不为0就不会被销毁，当然可以通过将对象赋值nil来就行销毁。<br>8.weak：weak修饰符表示指向但并不持有该对象，引用计数不会+1，在runtime中进行了相关操作，无需处理，自动销毁，用来修饰对象，多用于避免循环引用的地方。</p>
<h2 id="讲一下atomic的实现机制？为什么不能保证线程安全？"><a href="#讲一下atomic的实现机制？为什么不能保证线程安全？" class="headerlink" title="讲一下atomic的实现机制？为什么不能保证线程安全？"></a>讲一下atomic的实现机制？为什么不能保证线程安全？</h2><p>1.atomic是peoperty的修饰词之一，表示原子性的，使用方式为@property(atomic)int age;此时编译器会自动生成setter/getter方法，最终会调用objc_getProperty和objc_setProperty方法来进行存取属性。<br>此时用atomic修饰，在这两个方法内部使用os_unfair_lock（互斥锁）来进行加锁，保证读写的原子性，锁都在PropertyLocks中保存中，用之前都初始化好，到需要用到时，用对象的地址加上成员变量的偏移量为key，去PropertyLocks中去取，因此存取时用的是同一个锁，所以atomic能保证属性的存取时线程安全的。<br>2.atomic在getter/setter方法中加锁，仅保证了存取时的线程安全，假设我们的属性是@property(atomic)NSMutableArray * array;可变容器时，无法保证对容器的修改是线程安全的。</p>
<h2 id="import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import””有什么区别？"><a href="#import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import””有什么区别？" class="headerlink" title="#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？"></a>#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</h2><p>1.#import和#include都能完整地包含某个文件的内容，#import导入OC头文件，#include是导入C/C++头文件，#import能防止同一个文件被包含多次<br>2.@class仅仅是声明一个类名，并不会包含类的完整声明;@class还能解决循环包含的问题<br>3.#import &lt;&gt; 用来包含系统自带的文件，#import “”用来包含自定义的文件</p>
<h2 id="iOS中几种常见的设计模式？"><a href="#iOS中几种常见的设计模式？" class="headerlink" title="iOS中几种常见的设计模式？"></a>iOS中几种常见的设计模式？</h2><p>1.代理模式<br>一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。<br>2.观察者模式<br>KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。<br>3.MVC模式<br>Model View Control，把模型 视图 控制器 层进行解耦合编写。<br>4.单例模式<br>过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。<br>5.工厂模式<br>通过一个类方法，批量的根据已有模板生产对象。<br>6.MVVM模式<br>Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。</p>
<h2 id="为什么UI必须在主线程刷新"><a href="#为什么UI必须在主线程刷新" class="headerlink" title="为什么UI必须在主线程刷新?"></a>为什么UI必须在主线程刷新?</h2><p>UIKit并不是一个线程安全的类，UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</p>
<h2 id="数据持久化方式有哪些？"><a href="#数据持久化方式有哪些？" class="headerlink" title="数据持久化方式有哪些？"></a>数据持久化方式有哪些？</h2><p>1.plist：plist文件是将某些特定的类，通过XML文件的方式保存在目录中。<br>可以被序列化的类型只有如下几种：     NSArray; NSMutableArray; NSDictionary; NSMutableDictionary; NSData; NSMutableData; NSString; NSMutableString; NSNumber     <br>2.NSUserdefault：Library中Preferences应用程序的所有偏好设置iOS的Settings(设置)</p>
<p>3.NSKeyedArchiver：归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>
<p>4.数据库：适合储存数据量较大的数据,一般使用FMDB和CoreData来实现.<br>FMDB:<br>FMDB是iOS平台的SQLite数据库框架，FMDB以OC的方式封装了SQLite的C语言API，使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码，对比苹果自带的Core Data框架，更加轻量级和灵活，提供了多线程安全的数据库操作方法，有效地防止数据混乱。</p>
<p>CoreData:<br>Core Data是iOS5之后才出现的一个框架，它提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象。在此数据操作期间，我们不需要编写任何SQL语句.但是直接操作CoreData显的不是那么容易,所以我多数的时候会使用MagicRecord来实现.MagicRecord是对CoreData的二次封装,使用起来简单操作方便.</p>
<p>5.Keychain：<br>用于本地重要数据的存储,将数据加密后存储在本地更安全.如:密码,秘钥,序列号等.当你删除APP后Keychain存储的数据不会删除，所以在重装App后，Keychain里的数据还能使用。从ios 3.0开始，跨程序分享keychain变得可行而NSUserDefaults存储的数据会随着APP而删掉.<br>使用keychain时苹果官方已经为我们封装好了文件KeychainItemWrapper,引入即可使用.当然也可是使用其他优秀的第三方的封装,比如ssKeychain</p>
<p>6.沙盒写入<br>持久化在Document目录下，一般存储非机密数据。当App中涉及到电子书阅读、听音乐、看视频、刷图片列表等时，推荐使用沙盒存储。因为这可以极大的节约用户流量，而且也增强了app的体验效果.</p>
<ul>
<li>Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</li>
<li>Documents: 保存应⽤运行时生成的需要持久化的数据,iTunes同步设备时会备份该目录。例如,游戏应用可将游戏存档保存在该目录。</li>
<li>tmp: 保存应⽤运行时所需的临时数据,使⽤完毕后再将相应的文件从该目录删除。应用 没有运行时,系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。</li>
<li>Library/Caches: 保存应用运行时⽣成的需要持久化的数据,iTunes同步设备时不会备份 该目录。⼀一般存储体积大、不需要备份的非重要数据，比如网络数据缓存存储到Caches下</li>
<li>Library/Preference: 保存应用的所有偏好设置，如iOS的Settings(设置) 应⽤会在该目录中查找应⽤的设置信息。iTunes同步设备时会备份该目录。</li>
</ul>
<h2 id="alloc、init、new的区别和原理？"><a href="#alloc、init、new的区别和原理？" class="headerlink" title="alloc、init、new的区别和原理？"></a>alloc、init、new的区别和原理？</h2><p><strong>1.区别：</strong><br>1）new和alloc/init在功能上⼏乎是⼀致的，分配内存并完成初始化。<br>2）差别在于，采⽤new的⽅式只能采⽤默认的init⽅法完成初始化。<br>3）采⽤alloc的⽅式可以⽤其他定制的初始化⽅法。<br><strong>2.原理：</strong><br>1）每个对象内部都保存了⼀个与之相关联的整数，成为引⽤计数器。<br>2）每当使⽤alloc、new和copy创建⼀个对象时，对象的引⽤计数器被设置为1.<br>3）给对象发送⼀条retain消息，可以使引⽤计数器+1；<br>4）给对象发送⼀条release消息，可以使引⽤计数器-1；<br>5）当⼀个对象的引⽤计数器为0时，它被销毁，其占⽤内存被系统回收，oc也会⾃动向对象发送⼀条dealloc消息。⼀般会写dealloc⽅法，在这⾥被释放相关资源。<br>6）可以给对象发送retainCount消息获得当前的引⽤计数器值。</p>
<h2 id="常见的状态码？"><a href="#常见的状态码？" class="headerlink" title="常见的状态码？"></a>常见的状态码？</h2><ul>
<li>2xx 成功：200表示请求正常。</li>
<li>3xx 重定向：302是请求重定向。解决方法NSURLConnetion和NSURLSession进行拦截</li>
<li>4xx 客户端错误：400客户端请求的语法错误，404Not Found 找不到/请求失败</li>
<li>5xx 服务器错误：500 Internal Server Error 服务器的内部错误</li>
</ul>
<h2 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</h2><p>1.@property = ivar + getter + setter;<br>属性” (property)有两大概念:ivar（实例变量）、getter+setter（存取方法）<br>2.ivar、getter、setter 是自动合成这个类中的，在编译期执行的，自动生成带有下划线的_ivar实例变量和setter和getter方法<br>3.属性引用self.name与_name的区别？<br>self.name是对属性的访问，=左侧是调用setter方法，=号右侧是调用getter方法;可以在类外使用，_name不能在类外使用。<br>_name是对局部变量的访问。直接调用变量，不通过getter方法</p>
<h2 id="frame-和-bounds-有什么不同？"><a href="#frame-和-bounds-有什么不同？" class="headerlink" title="frame 和 bounds 有什么不同？"></a>frame 和 bounds 有什么不同？</h2><ul>
<li>frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)</li>
<li>bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</li>
</ul>
<h2 id="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？"><a href="#Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？" class="headerlink" title="Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？"></a>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</h2><ul>
<li>Objective-C的类不可以多重继承；</li>
<li>可以实现多个接口（协议）；</li>
<li>Category是类别；</li>
<li>一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</li>
</ul>
<h2 id="synthesize-和-dynamic-分别有什么作用？"><a href="#synthesize-和-dynamic-分别有什么作用？" class="headerlink" title="@synthesize 和 @dynamic 分别有什么作用？"></a>@synthesize 和 @dynamic 分别有什么作用？</h2><ul>
<li>@synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成</li>
</ul>
<h2 id="Objective-C-如何对内存管理的，说说你的看法和解决方法？"><a href="#Objective-C-如何对内存管理的，说说你的看法和解决方法？" class="headerlink" title="Objective-C 如何对内存管理的，说说你的看法和解决方法？"></a>Objective-C 如何对内存管理的，说说你的看法和解决方法？</h2><p>Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</p>
<ul>
<li>自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。编译器通过分析对象的生命周期，在合适的位置retain和release。</li>
<li>手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。</li>
<li>NSAutoRealeasePool（内存释放池）：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</li>
</ul>
<h2 id="非对称加密和对称加密有哪些？用过那个？"><a href="#非对称加密和对称加密有哪些？用过那个？" class="headerlink" title="非对称加密和对称加密有哪些？用过那个？"></a>非对称加密和对称加密有哪些？用过那个？</h2><ul>
<li><p>对称加密：又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。</p>
</li>
<li><p>非对称加密：非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。</p>
</li>
<li><p>如何进行双向加密呢？（非对称加密RSA）<br>iOS端和后台（这里后台使用的是java，因为我后台语言只会java，效果都是一样的）各生成自己的公钥和私钥。iOS端生成的公钥和私钥定义为iOSPublicKey、iOSPrivateKey，java端生成的公钥私钥定义为javaPublicKey、javaPrivateKey。将iOSPublicKey给java，让它用iOSPublicKey加密数据传给iOS端，iOS端用iOSPrivateKey解密；java端将javaPublicKey给iOS端，iOS端用javaPublicKey加密数据后上传给java，java端利用javaPrivateKey去解密，这样就实现了数据传输过程中的加密与解密，当然，也不一定非要按照我上面的步骤来，具体情况要和后台商量如何加密。</p>
</li>
</ul>
<h2 id="Method、SEL、IMP关系？"><a href="#Method、SEL、IMP关系？" class="headerlink" title="Method、SEL、IMP关系？"></a>Method、SEL、IMP关系？</h2><p>Method = SEL + IMP + method_types，相当于在SEL和IMP之间建立了一个映射</p>
<ul>
<li>Method：是一个objc_method的结构体,objc_method是类的一个方法描述</li>
<li>SEL：方法编号（方法名）</li>
<li>IMP：实际上是一个函数指针，指向方法实现的地址。</li>
<li>method_types：参数和返回类型的描述字串</li>
</ul>
<h2 id="UIViewController生命周期UIView的生命周期？"><a href="#UIViewController生命周期UIView的生命周期？" class="headerlink" title="UIViewController生命周期UIView的生命周期？"></a>UIViewController生命周期UIView的生命周期？</h2><ul>
<li>UIViewController生命周期：</li>
</ul>
<p>1.(void)load<br>load 在代码加载的时候，对象还没有被初始化的时候就已经调⽤了，可以⽤<br>来做⼀些全局的swizzle,只调⽤⼀次</p>
<p>2.+ (void)initialize<br>类的初始化方法</p>
<p>3.- (instancetype)init<br>对象初始化方法</p>
<p>4.-(void)loadView<br>加载视图:当访问UIViewController的view属性时，view如果此时是nil，那么VC会自动调用loadView方法来初始化一个UIView并赋值给view属性。此方法用在初始化关键view，需要注意的是，在view初始化之前，不能先调用view的getter方法，否则将导致死循环（除非先调用了[super loadView];）如果没有重载loadView方法，则UIViewController会从nib或StoryBoard中查找默认的loadView，默认的loadView会返回一个空白的UIView对象。</p>
<p>5.- (void)viewDidLoad<br>视图加载完成</p>
<p>6.-(void)viewWillAppear:(BOOL)animated<br>将要展示:,在view即将添加到视图层级中（显示给用户）且任意显示动画切换之前调用,此时self.view.superview为nil.这个方法中完成任何与试图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等。</p>
<p>7.-(void)viewWillLayoutSubviews<br>将要布局子视图,self.view.superview为_UIParallaxDimmingView</p>
<p>8.-(void)viewDidLayoutSubviews<br>已经布局子视图</p>
<p>9.-(void)viewDidAppear:(BOOL)animated<br>已经展示:在view被添加到视图层级中，显示动画切换之后调用（这时view已经添加到supperView中）。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用[supper viewDidAppear];,此时self.view.superview为UIViewControllerWrapperView。</p>
<p>10.-(void)viewWillDisappear:(BOOL)animated<br>将要消失:view即将从supperView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为UIViewControllerWrapperView.</p>
<p>11.-(void)viewDidDisappear:(BOOL)animated<br>已经消失:view从superView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为nil.</p>
<p>12.- (void)dideMemoryWarning<br>内存警告</p>
<p>13.-(void)dealloc<br>销毁释放</p>
<ul>
<li>UIView生命周期</li>
</ul>
<p>1.- (instancetype)init<br>构造方法,内部会调用initWithFrame方法</p>
<p>2.- (void)willToSuperview:(UIView *)newSuperview<br>父视图将要更改为指定的父视图,当前视图被添加到父视图时调用</p>
<p>3.- (void)didMoveToSuperview<br>父视图已更改</p>
<p>4.- (void)willMoveToWindow:(UIWindow *)newWindow<br>其窗口对象将要更改</p>
<p>5.- (void)didMoveToWindow<br>窗口对象已经更改</p>
<p>6.- (void)layoutSubviews<br>布局子控件</p>
<p>7.- (void)drawRect:(CGRect)rect<br>绘制视图</p>
<p>8.- (void)dealloc<br>销毁</p>
<h2 id="NSSet和NSArray的区别？"><a href="#NSSet和NSArray的区别？" class="headerlink" title="NSSet和NSArray的区别？"></a>NSSet和NSArray的区别？</h2><p>1.NSArray内存中存储地址连续，而NSSet不连续<br>2.NSSet效率高，内部使用hash查找；NSArray查找需要遍历<br>3.NSSet通过anyObject访问元素，NSArray通过下标访问</p>
<h2 id="如何⾼性能的给-UIImageView-加个圆⻆"><a href="#如何⾼性能的给-UIImageView-加个圆⻆" class="headerlink" title="如何⾼性能的给 UIImageView 加个圆⻆?"></a>如何⾼性能的给 UIImageView 加个圆⻆?</h2><p>1.Core Animation提前渲染屏幕的<br>离屏绘制, ⽽离屏绘制就会给性能带来负⾯影响，会有卡顿的现象出现。<br>self.view.layer.cornerRadius = 5.0f;<br>self.view.layer.masksToBounds = YES;<br>2.使用绘图<br>3.使用了贝塞尔曲线”切割”个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。</p>
<h2 id="以下代码运⾏结果如何？"><a href="#以下代码运⾏结果如何？" class="headerlink" title="以下代码运⾏结果如何？"></a>以下代码运⾏结果如何？</h2><p>1.主线程和主队列的相互等待，造成死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"> NSLog(@&quot;1&quot;);</span><br><span class="line"> dispatch_sync(dispatch_get_main_queue(),   ^&#123;</span><br><span class="line">     NSLog(@&quot;2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  NSLog(@&quot;3&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>结果：同步-主线程会造成死锁 ：输出结果只有1 </p>
<p>2.代码本身就是在主线程中写的，将其放到⼦线程中就可以避免造成死循环</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[super viewDidLoad];</span><br><span class="line"> NSLog(@&quot;1&quot;);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; </span><br><span class="line"> dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">         NSLog(@&quot;2&quot;);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"> NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：输出结果为1、3、2</p>
<h2 id="dispatch-barrier-async（栅栏函数）的作⽤是什么？"><a href="#dispatch-barrier-async（栅栏函数）的作⽤是什么？" class="headerlink" title="dispatch_barrier_async（栅栏函数）的作⽤是什么？"></a>dispatch_barrier_async（栅栏函数）的作⽤是什么？</h2><p>1.作⽤：<br>1）在它前⾯的任务执⾏结束后它才执⾏，它后⾯的任务要等它执⾏完成后才会开始执⾏。<br>2）避免数据竞争</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建并发队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;myQueue&quot;,</span><br><span class="line">DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">&#x2F;&#x2F; 向异步队列中添加并行任务</span><br><span class="line">dispatch_async(queue, ^&#123; </span><br><span class="line">    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">     NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">     NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">     NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">     NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果: 任务1 任务2 ——&gt; 任务 barrier ——&gt;任务3 任务4<br>其中的任务1与任务2，任务3与任务4 由于是并⾏处理先后顺序不定。</p>
<h2 id="根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？"><a href="#根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？" class="headerlink" title="根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？"></a>根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？</h2><p>1.方法一GCD的线程组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(void)Btn&#123;</span><br><span class="line">    NSString *str &#x3D; @&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6930f335adba&quot;;</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line">    &#x2F;&#x2F;创建线程组</span><br><span class="line">    dispatch_group_t downloadGroup &#x3D; dispatch_group_create();</span><br><span class="line">    for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;enter</span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        &#x2F;&#x2F;下载图片</span><br><span class="line">        NSURLSessionDataTask *task &#x3D; [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">            &#x2F;&#x2F;离开</span><br><span class="line">            dispatch_group_leave(downloadGroup);</span><br><span class="line">            </span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>dispatch_group_enter：通知group，下面的任务马上要放到group中执行了。<br>dispatch_group_leave：通知group，任务完成了，该任务要从group中移除了。<br>dispatch_group_notify：通知线程组中的任务都完成了</p>
<p>//2.GCD的信号量:信号量是基于计数器的一种多线程同步机制，用来管理对资源的并发访问。<br>简单来讲 信号量为0则阻塞线程，大于0则不会阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;semaphore--</span><br><span class="line">-(void)Btn&#123;</span><br><span class="line">    NSString *str &#x3D; @&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6930f335adba&quot;;</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 创建信号量，参数：信号量的初值，如果小于0则会返回NULL</span><br><span class="line">    dispatch_semaphore_t sem &#x3D; dispatch_semaphore_create(0);</span><br><span class="line">    for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        NSURLSessionDataTask *task &#x3D; [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">            count++;</span><br><span class="line">            if (count&#x3D;&#x3D;10) &#123;</span><br><span class="line">                &#x2F;&#x2F; 提高信号量， 使信号量加1并返回</span><br><span class="line">                dispatch_semaphore_signal(sem);</span><br><span class="line">                count &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 若信号的信号量为0，则会阻塞当前线程，直到信号量大于0或者经过输入的时间值；</span><br><span class="line">    &#x2F;&#x2F; 若信号量大于0，则会使信号量减1并返回，程序继续住下执行</span><br><span class="line">    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10个网络请求顺序回调"><a href="#10个网络请求顺序回调" class="headerlink" title="10个网络请求顺序回调?"></a>10个网络请求顺序回调?</h2><p>1.信号量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)Btn&#123;</span><br><span class="line">    NSString *str &#x3D; @&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6930f335adba&quot;;</span><br><span class="line">    NSURL *url &#x3D; [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t sem &#x3D; dispatch_semaphore_create(0);</span><br><span class="line">    for (int i&#x3D;0; i&lt;10; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        NSURLSessionDataTask *task &#x3D; [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [task resume];</span><br><span class="line">        &#x2F;&#x2F;让循环等待</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="你⼀般是怎么⽤nstruments的？Instruments⾥⾯⼯具很多，常⽤："><a href="#你⼀般是怎么⽤nstruments的？Instruments⾥⾯⼯具很多，常⽤：" class="headerlink" title="你⼀般是怎么⽤nstruments的？Instruments⾥⾯⼯具很多，常⽤："></a>你⼀般是怎么⽤nstruments的？Instruments⾥⾯⼯具很多，常⽤：</h2><ol>
<li>Time Profiler: 性能分析,CPU分析</li>
<li>Zombies：检查是否访问了僵⼫对象，但是这个⼯具只能从上往下检查，不智能。</li>
<li>Allocations：⽤来检查内存，写算法的那批⼈也⽤这个来检查。</li>
<li>Leaks：检查内存，看是否有内存泄露。</li>
<li>Core Animation：渲染分析，查看yellow。</li>
</ol>
<h2 id="isKindOfClass、isMemberOfClass、selector作⽤分别是什么"><a href="#isKindOfClass、isMemberOfClass、selector作⽤分别是什么" class="headerlink" title="isKindOfClass、isMemberOfClass、selector作⽤分别是什么?"></a>isKindOfClass、isMemberOfClass、selector作⽤分别是什么?</h2><p>1.isKindOfClass：作⽤是某个对象属于某个类型或者继承⾃某类型。<br>2.isMemberOfClass：某个对象确切属于某个类型。<br>3.selector：通过⽅法名，获取在内存中的函数的⼊⼝地址。</p>
<h2 id="类变量的-public，-protected，-private，-package-声明各有什么含义？"><a href="#类变量的-public，-protected，-private，-package-声明各有什么含义？" class="headerlink" title="类变量的 @public，@protected，@private，@package 声明各有什么含义？"></a>类变量的 @public，@protected，@private，@package 声明各有什么含义？</h2><p>1.@public 任何地⽅都能访问;<br>2.@protected 该类和⼦类中访问,是默认的;<br>3.@private 只能在本类中访问;<br>4.@package 本包内使⽤,跨包不可以。</p>
<h2 id="你是否接触过OC中的反射机制？简单聊⼀下概念和使⽤？"><a href="#你是否接触过OC中的反射机制？简单聊⼀下概念和使⽤？" class="headerlink" title="你是否接触过OC中的反射机制？简单聊⼀下概念和使⽤？"></a>你是否接触过OC中的反射机制？简单聊⼀下概念和使⽤？</h2><p>1.class反射类名的字符串形式实例化对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class &#x3D; NSClassFromString(@&quot;student&quot;);</span><br><span class="line">Student * stu &#x3D; [[class alloc] init];</span><br><span class="line">将类名变为字符串。</span><br><span class="line">Class class &#x3D;[Student class];</span><br><span class="line">NSString *className &#x3D; NSStringFromClass(class);</span><br></pre></td></tr></table></figure>
<p>2.SEL的反射<br>通过⽅法的字符串形式实例化⽅法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL selector &#x3D; NSSelectorFromString(@&quot;setName&quot;);</span><br><span class="line">[stu performSelector:selector withObject:@“Mike&quot;];</span><br><span class="line">将⽅法变成字符串。</span><br><span class="line">NSString * methodStr &#x3D; NSStringFromSelector(@selector*(setName:）</span><br></pre></td></tr></table></figure>

<h2 id="runtime-如何实现-weak-属性-weak属性如何自动置nil的？"><a href="#runtime-如何实现-weak-属性-weak属性如何自动置nil的？" class="headerlink" title="runtime 如何实现 weak 属性?weak属性如何自动置nil的？"></a>runtime 如何实现 weak 属性?weak属性如何自动置nil的？</h2><p>Runtime会对weak属性进行内存布局，构建hash表：表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的 weak 指针表作为 value。当对象引用计数为0 dealloc时，以key找到weak对象，将weak属性值自动置nil。</p>
<h2 id="NSHashTable和NSMapTable？"><a href="#NSHashTable和NSMapTable？" class="headerlink" title="NSHashTable和NSMapTable？"></a>NSHashTable和NSMapTable？</h2><p>1.NSHashTable：<br>1）NSHashTable是可变的，它没有不可变版本。无序、不重复的。<br>2）NSSet / NSMutableSet是对其成员的强类型引用，这些成员被通过hash方法和isEqual方法来完成哈希和对比功能<br>3）NSHashTable可以持有weak类型的成员变量<br>4）NSHashTable可以在添加成员变量的时候复制成员<br>5）NSHashTable可以随意的存储指针并且利用指针的唯一性来进行hash同一性检查（检查成员变量是否有重复）和对比操作（equal）<br>6）耗费的时间是NSSet的2倍。<br>2.NSMapTable<br>1）NSDictionary/NSMutableDictionary会复制keys并且通过强引用values来实现存储；<br>2）NSMapTable是可变的；<br>3）NSMapTable可以通过弱引用来持有keys和values，所以当key或者value被deallocated的时候，所存储的实体也会被移除；<br>4）NSMapTable可以在添加value的时候对value进行复制；</p>
<h2 id="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"><a href="#如何让自己的类用copy修饰符？如何重写带copy关键字的setter？" class="headerlink" title="如何让自己的类用copy修饰符？如何重写带copy关键字的setter？"></a>如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</h2><p>1.想让自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。实现 NSCopying 协议。该协议只有一个方法：- (id)copyWithZone:(NSZone *)zone;。<br>实现 NSMutableCopying 协议。该协议只有一个方法：- (id)mutableCopyWithZone:(nullable NSZone *)zone;<br>2.重写带 copy 关键字的 setter？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    _name &#x3D; [name copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.写一个setter方法用于完成@property(nonatomic,retain)NSString * name?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)str&#123;</span><br><span class="line">    &#x2F;&#x2F;ARC下不允许这么写</span><br><span class="line">    [str retain];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name &#x3D; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.写一个setter方法用于完成@property(nonatomic,copy)NSString * name?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)str&#123;</span><br><span class="line">    id t &#x3D; [str copy];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="一个objc对象如何进行内存布局？一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象如何进行内存布局？一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象如何进行内存布局？一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象如何进行内存布局？一个objc对象的isa的指针指向什么？有什么作用？</h2><p>每一个对象内部都有一个 isa 指针，指向他的类对象，类对象中存放着本对象的：<br>1）对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）。<br>2）成员变量的列表。<br>3）属性列表。<br>4）类对象内部也有一个 superclass 指针指向元对象(meta class)，元对象内部存放的是类方法列表。<br>5）元类对象内部还有一个 superclass (root class)的指针，指向他的根类对象。<br>6）根类对象就是NSObject，它的superclass指向nil</p>
<h2 id="objc-中的类方法和实例方法有什么本质区别和联系？"><a href="#objc-中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="objc 中的类方法和实例方法有什么本质区别和联系？"></a>objc 中的类方法和实例方法有什么本质区别和联系？</h2><p>1.类方法：<br>类方法是属于类对象的<br>类方法只能通过类对象调用<br>类方法中的 self 是类对象<br>类方法可以调用其他的类方法<br>类方法中不能访问成员变量<br>类方法中不能直接调用对象方法<br>2.实例方法：<br>实例方法是属于实例对象的<br>实例方法只能通过实例对象调用<br>实例方法中的 self 是实例对象<br>实例方法中可以访问成员变量<br>实例方法中直接调用实例方法<br>实例方法中也可以调用类方法（通过类名）</p>
<h2 id="objc-msgForward函数是做什么的，直接调用它将会发生什么？"><a href="#objc-msgForward函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="_objc_msgForward函数是做什么的，直接调用它将会发生什么？"></a>_objc_msgForward函数是做什么的，直接调用它将会发生什么？</h2><p>1._objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</p>
<p>2.详解：_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法：</p>
<ul>
<li>forwardingTargetForSelector:方法</li>
<li>methodSignatureForSelector:方法</li>
<li>forwardInvocation:方法</li>
<li>doesNotRecognizeSelector: 方法</li>
</ul>
<h2 id="LLDB常用的调试命令有哪些？"><a href="#LLDB常用的调试命令有哪些？" class="headerlink" title="LLDB常用的调试命令有哪些？"></a>LLDB常用的调试命令有哪些？</h2><p>1.p 输出基本类型。是打印命令，需要指定类型。是print的简写p。<br>2.po 打印对象，会调用对象description方法。是print-object的简写po。<br>3.expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。<br>4.bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈<br>5.br l：是breakpoint list的简写</p>
<h2 id="遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？如何解决卡顿问题？"><a href="#遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？如何解决卡顿问题？" class="headerlink" title="遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？如何解决卡顿问题？"></a>遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？如何解决卡顿问题？</h2><p>1.卡顿原因：CPU+GPU=绘制+渲染的事件&gt;16.7ms导致失帧或卡段<br>2.卡顿优化：本质上降低CPU、GPU 的工作，从这两个大的方面去提升性能。</p>
<ul>
<li><p>卡顿优化在 CPU 层面：<br>1）尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView<br>2）不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改<br>3）尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性<br>4）图片的 size 最好刚好跟 UIImageView 的 size 保持一致<br>5）控制一下线程的最大并发数量<br>6）尽量把耗时的操作放到子线程<br>文本处理（尺寸计算、绘制）<br>图片处理（解码、绘制）</p>
</li>
<li><p>卡顿优化在 GPU层面：<br>1）GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸<br>2）尽量减少视图数量和层次<br>3）减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES<br>4）尽量避免出现离屏渲染</p>
</li>
<li><p>tableView具体实现：<br>1）最常用的就是cell的重用， 注册重用标识符<br>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell；如果有很多数据的时候，就会堆积很多cell。<br>如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell。<br>2）避免cell的重新布局<br>cell的布局填充等操作比较耗时，一般创建时就布局好，如可以将cell单独放到一个自定义类，初始化时就布局好<br>3）提前计算并缓存cell的高度<br>当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度；而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入屏区都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell<br>4）减少cell中控件的数量<br>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，不适用的可以先隐藏。<br>5）不要使用ClearColor，无背景色，透明度也不要设置为0<br>渲染耗时比较长<br>6）使用局部更新<br>如果只是更新某组的话，使用reloadSection进行局部更新<br>7）加载网络数据，下载图片，使用异步加载，并缓存<br>8）少使用addView给cell动态添加view<br>9）按需加载cell，cell滚动很快时，只加载范围内的cell<br>10）不要实现无用的代理方法，tableView只遵守两个协议<br>11）不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。<br>12）预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；</p>
</li>
</ul>
<h2 id="什么是离屏渲染？CPU离屏渲染？GPU屏幕渲染类型？"><a href="#什么是离屏渲染？CPU离屏渲染？GPU屏幕渲染类型？" class="headerlink" title="什么是离屏渲染？CPU离屏渲染？GPU屏幕渲染类型？"></a>什么是离屏渲染？CPU离屏渲染？GPU屏幕渲染类型？</h2><p>1.如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。<br>2.大家知道，如果我们在UIView中实现了drawRect方法，就算它的函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作。<br>对于类似这种“新开一块CGContext来画图“的操作，有很多文章和视频也称之为“离屏渲染”（因为像素数据是暂时存入了CGContext，而不是直接到了frame buffer）。进一步来说，其实所有CPU进行的光栅化操作（如文字渲染、图片解码），都无法直接绘制到由GPU掌管的frame buffer，只能暂时先放在另一块内存之中，说起来都属于“离屏渲染”。<br>Xcode调试的“Color offscreen rendered yellow”开关，你会发现这片区域不会被标记为黄色，说明Xcode并不认为这属于离屏渲染。<br>其实通过CPU渲染就是俗称的“软件渲染”，而真正的离屏渲染发生在GPU。<br>3.当前屏幕渲染：GPU渲染操作就是在当前用于显示屏的帧缓冲区中<br>离屏渲染：GPU在当前屏幕帧缓冲区以外开辟一个新的帧缓冲区进行渲染操作</p>
<h2 id="事件响应链是如何传递的？"><a href="#事件响应链是如何传递的？" class="headerlink" title="事件响应链是如何传递的？"></a>事件响应链是如何传递的？</h2><p>1）事件传递：首先会加入到UIApplication事件队列-&gt;UIWindow-&gt;UIViewController-&gt;View-&gt;subViews<br>查看view的过程是一个递归的过程，通过pointSide判断点是否在视图上，<br>通过hitTest递归查找是否存在最合适的view，存在则返回<br>2）事件响应：subViews-&gt;view-&gt;controller-&gt;UIWindow-&gt;UIApplication<br>只要重写touches就会响应，一直向上响应</p>
<h2 id="静态库和动态库的区别？"><a href="#静态库和动态库的区别？" class="headerlink" title="静态库和动态库的区别？"></a>静态库和动态库的区别？</h2><p>1.静态库： .a和.framework</p>
<p>2.动态库：.dylib和.framework<br>1）动态库在程序运行时由系统动态加载到内存，供程序调用，如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。<br>2）动态库的文件会比较小，因为在编译过程中，数据并没有整合到目标代码中，只有在执行到该函数时才去调用库中的函数，所以首次加载时比较耗时。<br>3）多个程序可以共享内存中同一份库资源，系统只加载一次，多个程序可共用，节省内存空间。<br>4）库是动态的，因此修改库中函数时，不需要重新编译。</p>
<h2 id="NSCoding协议是干什么用的？"><a href="#NSCoding协议是干什么用的？" class="headerlink" title="NSCoding协议是干什么用的？"></a>NSCoding协议是干什么用的？</h2><p>一种编码协议，归档时和解档时需要依赖该协议定义的编码和解码方法。Foundation和Cocoa Touch中的大部分类都遵循了这个协议，一般被NSKeyedArchiver做自定义对象持久化时使用。</p>
<h2 id="Category-的实现原理？Category-在编译过后，是在什么时机与原有的类合并到一起的？"><a href="#Category-的实现原理？Category-在编译过后，是在什么时机与原有的类合并到一起的？" class="headerlink" title="Category 的实现原理？Category 在编译过后，是在什么时机与原有的类合并到一起的？"></a>Category 的实现原理？Category 在编译过后，是在什么时机与原有的类合并到一起的？</h2><p>1.实现原理：<br>1）Category 实际上是 Category_t 的结构体，在运行时通过 Runtime，新添加的方法都被以倒序插入到原有方法列表的最前面，所以不同的 Category，添加了同一个方法，执行的实际上是最后一个。 拿方法列表举例，实际上是一个二维的数组。 Category 如果翻看源码的话就会知道实际上是一个 _catrgory_t 的结构体。<br>2）所以所category并不是覆盖方法，而且并不是把所有方法都插入到最前面，而是把当前正在调用的方法放在同名方法的最前面，是一个复杂度的编译操作。</p>
<p>2.时机：<br>1）程序启动后，通过编译之后，Runtime 会进行初始化，调用 _objc_init。<br>2）然后会 map_images镜像。<br>3）接下来调用 map_images_nolock。<br>4）再然后就是 read_images，这个方法会读取所有的类的相关信息。<br>5）最后是调用 reMethodizeClass:，这个方法是重新方法化的意思。<br>6）在 reMethodizeClass: 方法内部会调用 attachCategories: ，这个方法会传入 Class 和 Category ，会将方法列表，协议列表等与原有的类合并。最后加入到 class_rw_t 结构体</p>
<h2 id="用伪代码写一个线程安全的单例模式？"><a href="#用伪代码写一个线程安全的单例模式？" class="headerlink" title="用伪代码写一个线程安全的单例模式？"></a>用伪代码写一个线程安全的单例模式？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static DLManager * instance &#x3D; nil;</span><br><span class="line">+ (instancetype)shareManager&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance &#x3D; [[DLManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance &#x3D; [[DLManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dealloc-调用流程"><a href="#Dealloc-调用流程" class="headerlink" title="Dealloc 调用流程"></a>Dealloc 调用流程</h2><p>1.首先调用 _objc_rootDealloc()<br>2.接下来调用 rootDealloc()<br>3.这时候会判断是否可以被释放，判断的依据主要有5个，判断是否有以上五种情况<br>NONPointer_ISA<br>weakly_reference<br>has_assoc<br>has_cxx_dtor<br>has_sidetable_rc<br>4-1.如果有以上五中任意一种，将会调用 object_dispose()方法，做下一步的处理。<br>4-2.如果没有之前五种情况的任意一种，则可以执行释放操作，C函数的 free()。<br>5.执行完毕。</p>
<p>object_dispose() 调用流程。<br>1）直接调用 objc_destructInstance()。<br>2）之后调用 C函数的 free()。</p>
<p>objc_destructInstance() 调用流程：<br>1）先判断 hasCxxDtor，如果有 C++ 的相关内容，要调用 object_cxxDestruct() ，销毁 C++ 相关的内容。<br>2）再判断 hasAssocitatedObjects，如果有的话，要调用 object_remove_associations()，销毁关联对象的一系列操作。<br>3）然后调用 clearDeallocating()。<br>4）执行完毕。</p>
<p>clearDeallocating() 调用流程：<br>1）先执行 sideTable_clearDellocating()。<br>2）再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。<br>3）接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。<br>4）至此为止，Dealloc 的执行流程结束。</p>
<h1 id="循环引用的几种情况和解决方式？"><a href="#循环引用的几种情况和解决方式？" class="headerlink" title="循环引用的几种情况和解决方式？"></a>循环引用的几种情况和解决方式？</h1><p>1.Block<br>原因： self 强引用了 block，而 block 内部又调用了 self<br>解决： 使用 Weak-Strong Dance</p>
<p>2.Delegate<br>原因：委托者和被委托人之间的相互强引用问题strong<br>解决：用weak 进行弱引用 或者 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和再动态解析，直接进行消息转发)</p>
<p>3.NSTimer<br>原因：self → timer → self(target) 的循环持有链<br>解决：在适当的时机销毁[_timer invalidate];_timer = nil;</p>
<p>4.对象之间的循环引用问题<br>循环引用的实质：多个对象相互之间有强引用，不能施放让系统回收。解决办法：使用 weak 打破对象之间的相互强引用</p>
<p>5.通知的循环引用<br>iOS9 以后，一般的通知，都不再需要手动移除观察者，系统会自动在dealloc 的时候调用 [[NSNotificationCenter defaultCenter] removeObserver: self]。iOS9 以前的需要手动进行移除</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>1.数组：有序、下标取值、内存连续。<br>查找：所以使用下标取值（因为内存连续，且存储单元大小已知，所以可以快速定位下标所在的内存地址）的时候很快能找到，比链表快多了。<br>插入：但是插入的时候，需要挪动本下标后边的所有内存地址，往后移一个单元。所以如果插入不是在尾部，并且数据量很大的情况下，会比链表慢。但是：OC中的数组对此采用了环形缓冲区的优化，它的作用是可以计算出移动最少的内存来达到目的。比如，如果距离开头近，就会移动头部的内存；距离尾部近，就会移动尾部的内存。而环形缓冲区是靠链表实现的。</p>
<p>2.链表：有序、本节点保存有下一节点的地址、内存不连续（不能使用下标取值）。<br>查找：只能从头开始查找，所以查找比数组慢。<br>插入：插入的成本很低，只需要打断两个节点插入后重新连接上就行，对其他不相关节点毫无影响。比数组快。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="category能否添加属性，为什么？能否添加实例变量，为什么？"><a href="#category能否添加属性，为什么？能否添加实例变量，为什么？" class="headerlink" title="category能否添加属性，为什么？能否添加实例变量，为什么？"></a>category能否添加属性，为什么？能否添加实例变量，为什么？</h2><p>1.可以添加属性<br>这里的属性指@property，但跟类里的@property又不一样。正常的@property为：实例变量Ivar + Setter + Getter 方法，分类里的@property这三者都没有，需要我们手动实现。<br>对于分类自定义Setter和Getter方法，我们可以通过关联对象（Associated Object）进行实现。</p>
<p>2.无法添加实例变量<br>分类是运行时被编译的，这时类的结构已经固定了，所以我们无法添加实例变量。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="ARC方案的原理是什么？它是在什么时候做的隐士添加release？"><a href="#ARC方案的原理是什么？它是在什么时候做的隐士添加release？" class="headerlink" title="ARC方案的原理是什么？它是在什么时候做的隐士添加release？"></a>ARC方案的原理是什么？它是在什么时候做的隐士添加release？</h2><p>1。当我们编译源码的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数操作代码，在合适的地方retain和release<br>2.编译器前端：<br>方法法里面创建了一个对象，前端编译器会在方法末尾自动添加release语句销毁它。<br>类拥有的对象（实例变量／属性）在dealloc方法内释放(笔者注：生命周期结束的时候加入release)<br>3.优化器:当代码中出现多个对 retain 和release的重复调用，ARC优化器负责移出多余的 retain 和release语句。</p>
<h2 id="AutoreleasePool的实现机制是什么？实现原理是什么？他是什么时候释放内部对象的？它内部的数据结构是什么样子的？哪些对象会放入到AutoreleasePool中？"><a href="#AutoreleasePool的实现机制是什么？实现原理是什么？他是什么时候释放内部对象的？它内部的数据结构是什么样子的？哪些对象会放入到AutoreleasePool中？" class="headerlink" title="AutoreleasePool的实现机制是什么？实现原理是什么？他是什么时候释放内部对象的？它内部的数据结构是什么样子的？哪些对象会放入到AutoreleasePool中？"></a>AutoreleasePool的实现机制是什么？实现原理是什么？他是什么时候释放内部对象的？它内部的数据结构是什么样子的？哪些对象会放入到AutoreleasePool中？</h2><p>1.自动释放池原理：</p>
<ul>
<li>每个自动释放池都是是由若干个AutoreleasePoolPage组成的双向链表结构，每张链表头尾相接，内部属性有 parent，child 对应前后两个结点，分别指向上一个和下一个page；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；</li>
<li>另外，最外层池子的顶端会有一个next 指针。当next== begin()时，表示AutoreleasePoolPage为空；当next == end()，表示AutoreleasePoolPage已满，当链表容量满了，就会在链表的顶端，并指向下一张表。</li>
<li>每创建一个池子，会在首部创建一个哨兵对象,作为标记区分不同的自动释放池；</li>
</ul>
<p>2.App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer 其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。<br>第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用_objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池。<br>Exit(即将退出 Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>autoreleasepool在drain的时候回释放其中分配的对象。主线程休眠销毁前一个自动释放池，创建一个新的。子线程内部创建自动释放池，因为与runloop一一对应，当结束时销毁runloop</p>
<p>3.哪些对象会放入到Autoreleasepool中？<br>有两种情况生成的对象会加入到autoreleasepool中：</p>
<ul>
<li>非alloc/new/copy/mutablecopy 开始的方式初始化时。</li>
<li>id的指针或对象的指针在没有显示指定时</li>
</ul>
<h2 id="weak的实现原理是什么？当引用对象销毁时，它是如何管理内部hash表的？"><a href="#weak的实现原理是什么？当引用对象销毁时，它是如何管理内部hash表的？" class="headerlink" title="weak的实现原理是什么？当引用对象销毁时，它是如何管理内部hash表的？"></a>weak的实现原理是什么？当引用对象销毁时，它是如何管理内部hash表的？</h2><p>1.runtime 对注册的类会进行布局，对于 weak 修饰的对象会放入一个 hash 表中。 其实 Weak 表是一个 hash（哈希）表，Key 是 weak 所指对象的地址，Value 是 weak 指针的地址（这个 地址的值是所指对象指针的地址）数组。用 weak 指向的对象内 存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，用key 在这个 weak 表中搜索，找到所有以 key 为键的 weak 对象，从而设置为 nil。</p>
<p>2.管理：<br>1)初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。<br>2)添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。<br>3).释放时,调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</p>
<h1 id="runLoop"><a href="#runLoop" class="headerlink" title="runLoop"></a>runLoop</h1><h2 id="RunLoop是什么，有什么作用，原理？"><a href="#RunLoop是什么，有什么作用，原理？" class="headerlink" title="RunLoop是什么，有什么作用，原理？"></a>RunLoop是什么，有什么作用，原理？</h2><p>1.概念<br>RunLoop又叫运行循环，内部就是一个do-while循环，在这个循环内部不断处理各种任务，保证程序持续运行。RunLoop存在的目的就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息</p>
<p>2.RunLoop的作用<br>1)保持程序持续运行。<br>App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。<br>2)处理App中各类事件。<br>事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。<br>3)节省CPU资源，提高程序性能。<br>如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</p>
<p>3.原理<br>平时所讲的RunLoop有两种， 一种是NSRunLoop，一种CFRunLoop，NSRunLoop是存在于Foundation框架中，CFRunLoop是存在于CoreFoundation框架中的。平时我们使用的是NSRunLoop，其实NSRunLoop是基于CFRunLoop的一层简单的OC封装，CFRunLoop本质是一个结构体，NSRunLoop是一个NSObject对象。NSRunLoop不是线程安全的，CFRunLoop时候线程安全的。那么我们通过源码了解一下CFRunLoop。首先看下基本数据结构。<br>CFRunLoop是一个结构体，里面含有很多属性。看一下这个结构体里面我们需要关注的几个参数。每一个RunLoop都有自己的模式（Mode），而且不止一个模式。模式（Mode）里面存储的是RunLoop要处理的事件源，事件源有三种，Source、Timer、Observer这三种，下面会有详细介绍。RunLoop有很多模式，但是某一个时刻只能有一个确定的Mode，就是_currentMode。<br>上面说RunLoop是用来处理事件，它处理的事件主要有三种，Source、Timer、Observer，那么Source还可以分为两种，Source0和Source1。<br>CFRunLoopRun 和CFRunLoopRunInMode 内部都调用了CFRunLoopRunSpecific。而CFRunLoopRunSpecific内部又调用了__CFRunLoopRun,CFRunLoopRunSpecific和__CFRunLoopRun 合起来就是RunLoop的完整实现了</p>
<p>4.RunLoop接收几种输入源，系统默认定义了几种模式？<br>1）输入源有两种<br>基于端口的输入源（port）<br>自定义的输入源（custom）<br>2）系统定义的RunLoop模式有五种，最常用的有三种，如下所示：<br>NSDefaultRunLoopMode<br>默认模式，主线程中默认是NSDefaultRunLoopMode<br>UITrackingRunLoopMode<br>视图滚动模式，RunLoop会处于该模式下<br>NSRunLoopCommonModes<br>并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</p>
<h2 id="RunLoop模式的原理和使用注意点？"><a href="#RunLoop模式的原理和使用注意点？" class="headerlink" title="RunLoop模式的原理和使用注意点？"></a>RunLoop模式的原理和使用注意点？</h2><p>1.原理和注意点<br>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source、Observer、Timer。每次RunLoop启动，只能指定一个Mode，这个Mode被称为CurrentMode<br>如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入， 以使不同组之间的Source、Observer、Timer互不受影响。</p>
<h2 id="RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？"><a href="#RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？" class="headerlink" title="RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？**"></a>RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？**</h2><p>1）每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动<br>2）mode：主要用来指定事件在运行时循环的优先级<br>3）作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</p>
<h2 id="可以用Runloop实现什么功能？"><a href="#可以用Runloop实现什么功能？" class="headerlink" title="可以用Runloop实现什么功能？"></a>可以用Runloop实现什么功能？</h2><p>检测卡顿<br>线程保活<br>性能优化，将一些耗时操作放到runloop wait的情况处理。</p>
<h2 id="NSTimer和RunLoop的关系？"><a href="#NSTimer和RunLoop的关系？" class="headerlink" title="NSTimer和RunLoop的关系？"></a>NSTimer和RunLoop的关系？</h2><p>1.主线程下NSTimer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.默认添加到主线程的runloop，自己执行</span><br><span class="line">_timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;2.默认添加到主线层的runloop,自动执行</span><br><span class="line">_timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;3.不会执行，需要添加到主线程的runloop</span><br><span class="line">_timer &#x3D; [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;4.不会执行，需要添加到主线程的runloop</span><br><span class="line">_timer &#x3D; [NSTimer timerWithTimeInterval:1 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<p>2.子线程下的NSTimer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子线程下的NSTimer默认不执行，需要开启runloop,其他的和上面的一样</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">     dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">         _timer &#x3D; [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">             NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">         &#125;];</span><br><span class="line">        [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [[NSRunLoop currentRunLoop]run];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="NSTimer准确吗，如果不准确，如何设计一个准确的timer？"><a href="#NSTimer准确吗，如果不准确，如何设计一个准确的timer？" class="headerlink" title="NSTimer准确吗，如果不准确，如何设计一个准确的timer？"></a>NSTimer准确吗，如果不准确，如何设计一个准确的timer？</h2><p>1.不准确：原因如下<br>1）NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。<br>2）模式的改变。主线程的 RunLoop 里有两个预置的 Mode：DefaultMode 和 TrackingMode。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。</p>
<p>2.设计：<br>1）在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定 CommonModes（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。<br>2）在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；</p>
<h2 id="TableView-ScrollView-CollectionView滚动时为什么NSTimer会停止？"><a href="#TableView-ScrollView-CollectionView滚动时为什么NSTimer会停止？" class="headerlink" title="TableView/ScrollView/CollectionView滚动时为什么NSTimer会停止？"></a>TableView/ScrollView/CollectionView滚动时为什么NSTimer会停止？</h2><p>一个RunLoop不能同时共存两个mode，当滚动视图滚动时，当前RunLoop处于UITrackingRunLoopMode，NSTimer的RunLoopMode和当前线程的RunLoopMode不一致，所以会停止。<br>解决方法：将timer的runloopMode改UITrackingRunLoopMode或者NSRunLoopCommonModes。</p>
<h2 id="如果NSTimer在分线程中创建，会发生什么，应该注意什么？"><a href="#如果NSTimer在分线程中创建，会发生什么，应该注意什么？" class="headerlink" title="如果NSTimer在分线程中创建，会发生什么，应该注意什么？"></a>如果NSTimer在分线程中创建，会发生什么，应该注意什么？</h2><p>1）NSTimer没有启动<br>在主线程中，系统默认创建并启动主线程的runloop<br>在分线程中，系统不会自动启动runloop，需要手动启动<br>2）解决方法：<br>启动分线程的runLoop</p>
<h2 id="在异步线程中下载很多图片-如果失败了-该如何处理-请结合RunLoop来谈谈解决方案"><a href="#在异步线程中下载很多图片-如果失败了-该如何处理-请结合RunLoop来谈谈解决方案" class="headerlink" title="在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案"></a>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案</h2><p>在异步线程中启动一个RunLoop重新发送网络请求,下载图片</p>
<h2 id="如果程序启动就需要执行一个耗时操作，你会怎么做？"><a href="#如果程序启动就需要执行一个耗时操作，你会怎么做？" class="headerlink" title="如果程序启动就需要执行一个耗时操作，你会怎么做？"></a>如果程序启动就需要执行一个耗时操作，你会怎么做？</h2><p>开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作</p>
<h2 id="程序启动时，runloop是如何工作的？如果程序启动就需要执行一个耗时操作，你会怎么做？"><a href="#程序启动时，runloop是如何工作的？如果程序启动就需要执行一个耗时操作，你会怎么做？" class="headerlink" title="程序启动时，runloop是如何工作的？如果程序启动就需要执行一个耗时操作，你会怎么做？"></a>程序启动时，runloop是如何工作的？如果程序启动就需要执行一个耗时操作，你会怎么做？</h2><p>1.工作原理：<br>1）程序启动时，系统默认创建并启动主线程的runloop，runloop会默认创建两个Observe来进行监听runloop的进出和睡眠，有事情的时候就去做，没事的休眠<br>2）线程(创建)–&gt;runloop将进入–&gt;最高优先级创建释放池–&gt;runloop将睡–&gt;最低优先级销毁旧池创建新池–&gt;runloop将退出–&gt;最低优先级销毁新池–&gt;线程(销毁))<br>2.线程刚创建时并没有runloop，如果你不主动去获取，那么一直都不会有。耗时操作可以放在子线程中进行，结束后回到主线程</p>
<h1 id="经常问的面试题："><a href="#经常问的面试题：" class="headerlink" title="经常问的面试题："></a>经常问的面试题：</h1><h2 id="为什么只有主线程的runloop是开启的？"><a href="#为什么只有主线程的runloop是开启的？" class="headerlink" title="为什么只有主线程的runloop是开启的？"></a>为什么只有主线程的runloop是开启的？</h2><p>在主线程中，系统默认创建并启动主线程的runloop</p>
<h2 id="为什么只在主线程刷新UI？"><a href="#为什么只在主线程刷新UI？" class="headerlink" title="为什么只在主线程刷新UI？"></a>为什么只在主线程刷新UI？</h2><p>1.程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。<br>2.而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新</p>
<h2 id="PerformSelector和runloop的关系？"><a href="#PerformSelector和runloop的关系？" class="headerlink" title="PerformSelector和runloop的关系？"></a>PerformSelector和runloop的关系？</h2><p>1.基础用法：默认在主线程的runloop，会执行，因为此方法是发送消息,objc_msgSend</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(name:) withObject:@“张建&quot;];</span><br></pre></td></tr></table></figure>
<p>2.在子线程中执行会不会调用test方法，默认没有开启子线程的runloop不会执行，子线程中两者的顺序必须是先执行performSelector延迟方法之后再执行run方法。因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [super touchesBegan:touches withEvent:event];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        [self performSelector:@selector(testPerform) withObject:nil afterDelay:0];&#x2F;&#x2F;</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)testPerform&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：1.3<br>看文档中对这个API的注释是说，这个方法调用后，在当前runloop里设置了一个timer，来触发这个方法执行。而当前这个方法是在子线程中调用的，在子线程中runloop不是自动创建并跑起来的，需要手动调用，才会创建。因为这个在子线程中的调用没有创建runloop，所以就没有执行testPerform。</p>
<p>3.如何更改上面的方法使之打印2呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [super touchesBegan:touches withEvent:event];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        [self performSelector:@selector(testPerform) withObject:nil afterDelay:0];</span><br><span class="line">        NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：123</p>
<h2 id="如何使线程保活"><a href="#如何使线程保活" class="headerlink" title="如何使线程保活"></a>如何使线程保活</h2><p>runloop中如果没有observers, timers ，sources 等事件 就会退出当前runloop，而保活线程，就是不让rooloop退出，一直处于运行状态。</p>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><h2 id="什么是Block？"><a href="#什么是Block？" class="headerlink" title="什么是Block？"></a>什么是Block？</h2><p>Block 是将函数及其执行上下文封装起来的对象。<br>通过 clang 命令编译该.m 文件，发现该 block 结构体内部有 isa 指针，所以说其本质也是 OC 对象</p>
<h2 id="Block是如何实现的？Block对应的数据结构是什么样子的？-block的作用是什么？它对应的数据结构又是什么样子的？"><a href="#Block是如何实现的？Block对应的数据结构是什么样子的？-block的作用是什么？它对应的数据结构又是什么样子的？" class="headerlink" title="Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？"></a>Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？</h2><p>1）block本质是一个对象，底层用struct实现。<br>数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    &#x2F;* Imported variables. *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>isa 指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li>flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</li>
<li>reserved，保留变量。</li>
<li>invoke，函数指针，指向具体的 block 实现的函数调用地址。</li>
<li>descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li>
<li>variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>
</ul>
<p>2）__block的作用是可以获取对应变量的指针，使其可以在block内部被修改。通过反编译的代码我们可以看到该对象是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">    void *__isa;</span><br><span class="line">    __Block_byref_i_0 *__forwarding;</span><br><span class="line">    int __flags;</span><br><span class="line">    int __size;</span><br><span class="line">    int val; &#x2F;&#x2F;变量名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Block的分类？"><a href="#Block的分类？" class="headerlink" title="Block的分类？"></a>Block的分类？</h2><p>分为全局Block(_NSConcreteGlobalBlock)、<br>栈Block(_NSConcreteStackBlock)、<br>堆Block(_NSConcreteMallocBlock)三种形式<br>其中栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区。<br>堆：动态分配内存，需要程序员自己申请，程序员自己管理<br>栈： 自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</p>
<h2 id="为什么当我们在使用block时外面是weak-声明一个weakSelf，还要在block内部使用strong再持有一下？"><a href="#为什么当我们在使用block时外面是weak-声明一个weakSelf，还要在block内部使用strong再持有一下？" class="headerlink" title="为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？"></a>为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？</h2><p>block外界声明weak是为了实现block对对象的弱持有，而里面的作用是为了保证在进到block时不会发生释放。</p>
<h2 id="为什么-block能够修改外部变量？"><a href="#为什么-block能够修改外部变量？" class="headerlink" title="为什么__block能够修改外部变量？"></a>为什么__block能够修改外部变量？</h2><p>实际上__block是把外部变量的指针copy进堆，通过指针可以找到内存地址进而修改变量值，所以能进行a++。</p>
<h2 id="block修饰变量和对象的区别？"><a href="#block修饰变量和对象的区别？" class="headerlink" title="__block修饰变量和对象的区别？"></a>__block修饰变量和对象的区别？</h2><p>__block修饰的变量在block结构体中一直都是强引用，而其他类型的是由传入的对象指针类型决定。</p>
<h2 id="Block用copy修饰还是strong修饰？"><a href="#Block用copy修饰还是strong修饰？" class="headerlink" title="Block用copy修饰还是strong修饰？"></a>Block用copy修饰还是strong修饰？</h2><p>block用copy和strong修饰都可以。</p>
<h2 id="Block变量截获？"><a href="#Block变量截获？" class="headerlink" title="Block变量截获？"></a>Block变量截获？</h2><p>1.block有自动补获外部变量的能力。<br>1）局部变量截获：会被block捕获到内部，捕获了变量的值，是值传递。<br>2）局部静态变量、__block修饰的变量：会被block捕获到内部，捕获了变量的指针地址，可以修改值<br>3）全局变量，静态全局变量截获：没有捕获，会直接访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量</span><br><span class="line">NSInteger num4 &#x3D; 3000;</span><br><span class="line">&#x2F;&#x2F;静态全局变量</span><br><span class="line">static NSInteger num5 &#x3D; 30000;</span><br><span class="line"></span><br><span class="line">- (void)blockTest&#123;</span><br><span class="line">    &#x2F;&#x2F;局部变量</span><br><span class="line">    NSInteger num &#x3D; 3;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;局部静态变量</span><br><span class="line">    static NSInteger num2 &#x3D; 30;</span><br><span class="line">    &#x2F;&#x2F;局部__block变量</span><br><span class="line">    __block NSInteger num3 &#x3D; 300;</span><br><span class="line">    void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">        </span><br><span class="line">         NSLog(@&quot;%zd&quot;,num);</span><br><span class="line">        &#x2F;&#x2F;    -局部变量-值截取</span><br><span class="line">SLog(@&quot;%zd&quot;,num2);&#x2F;&#x2F;局部静态变量-指针截取</span><br><span class="line">        NSLog(@&quot;%zd&quot;,num3);&#x2F;&#x2F;局部__block变量-指针截取</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%zd&quot;,num4);&#x2F;&#x2F;全局变量-不截取直接取值</span><br><span class="line">        NSLog(@&quot;%zd&quot;,num5);&#x2F;&#x2F;全局静态变量-不截取直接取值</span><br><span class="line">    &#125;;</span><br><span class="line">      &#x2F;&#x2F;局部变量</span><br><span class="line">    num &#x3D; 40;</span><br><span class="line">    &#x2F;&#x2F;局部静态变量</span><br><span class="line">    num2 &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F;局部__block变量</span><br><span class="line">    num5 &#x3D; 40000;</span><br><span class="line">    &#x2F;&#x2F;全局变量</span><br><span class="line">    num3 &#x3D; 400;</span><br><span class="line">    &#x2F;&#x2F;全局静态变量</span><br><span class="line">    num4 &#x3D; 4000;</span><br><span class="line">    block();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-06-29 05:45:36.297656+0800 变量截取[82811:3663287] 3</span><br><span class="line">2020-06-29 05:45:36.297871+0800 变量截取[82811:3663287] 4</span><br><span class="line">2020-06-29 05:45:36.297997+0800 变量截取[82811:3663287] 400</span><br><span class="line">2020-06-29 05:45:36.298105+0800 变量截取[82811:3663287] 4000</span><br><span class="line">2020-06-29 05:45:36.298231+0800 变量截取[82811:3663287] 40000</span><br></pre></td></tr></table></figure>

<p><strong>4.为什么auto变量是值传递？static变量是指针传递？</strong><br>1）因为auto类型的局部变量 出了自己的作用域就被销毁了，这个变量就不存在了，它原来所占的内存就变成了垃圾内存了，不可以再访问，所以针对这种变量就需要在创建block的时候马上保存到block内部，否则在运行block的时候这个变量就可能没了，所以在block创建之后再怎么改变这个变量的值，运行block的时候依然是之前的值 。</p>
<p>2）而static局部变量虽然出了作用域也不能访问，但它的内存是一直存在的，不会销毁，所以block只需要在运行的时候能访问到它就可以，所以针对这种变量block采用的是指针传递，block内部只要保存这个变量的内存地址就可以保证在block运行的时候访问到这个变量，而正因为是指针传递，多以block在运行的时候总能够访问到这个变量最新的值。</p>
<p>3)看到这里，我们也很容易明白为什么全局变量不用捕获，因为全局变量既不会被销毁，也可以随处访问，所以block根本不用去捕获它也可能随时随地访问到它的值。</p>
<h2 id="assign-和-weak都是弱引用声明类型，最大的区别是？"><a href="#assign-和-weak都是弱引用声明类型，最大的区别是？" class="headerlink" title="assign 和 weak都是弱引用声明类型，最大的区别是？"></a>assign 和 weak都是弱引用声明类型，最大的区别是？</h2><p>weak 声明的变量对象释放后，赋值为nil<br>assign 声明的变量对象释放后不会自动赋值为nil，会造成野指针错误!</p>
<h2 id="Block和-weak的区别"><a href="#Block和-weak的区别" class="headerlink" title="__Block和__weak的区别"></a>__Block和__weak的区别</h2><p>1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型饰对象（NSString），不能修饰基本数据类型（int）。<br>2.__weak只能在ARC模式下使用，也只能修饰对象(NSString)，不能修饰基本数据类型(int)。<br>3.__block对象可以在block中被重新赋值，__weak不可以</p>
<h2 id="block和delegate区别？"><a href="#block和delegate区别？" class="headerlink" title="block和delegate区别？"></a>block和delegate区别？</h2><p>1.delegate运⾏成本低，block运⾏成本⾼。<br>2.delegate是weak弱引⽤；block是copy修饰。<br>3.block直接访问上下⽂，块和块实现在同⼀个地⽅，代码组织更加连贯。delegate声明和⽅法分离开来，代码的连贯性不是很好。</p>
<h2 id="以下代码是否可以正确执行？"><a href="#以下代码是否可以正确执行？" class="headerlink" title="以下代码是否可以正确执行？"></a>以下代码是否可以正确执行？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; [NSMutableArray array]; Block block &#x3D; ^&#123; [array addObject: @“5&quot;]；     [array addObject: @&quot;5&quot;];     NSLog(@&quot;%@&quot;,array); &#125;; block();</span><br></pre></td></tr></table></figure>
<p>可以正确执行，因为在block块中仅仅是使用了array的内存地址，往内存地址中添加内容，并没有修改arry的内存地址，因此array不需要使用__block修饰也可以正确编译。</p>
<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h2 id="KVO的实现原理？-KVO的本质是什么？"><a href="#KVO的实现原理？-KVO的本质是什么？" class="headerlink" title="KVO的实现原理？(KVO的本质是什么？)"></a>KVO的实现原理？(KVO的本质是什么？)</h2><p>当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的NSKVONotifing_Person子类，子类重写set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。</p>
<h2 id="KVO监听方法可以在子线程吗"><a href="#KVO监听方法可以在子线程吗" class="headerlink" title="KVO监听方法可以在子线程吗?"></a>KVO监听方法可以在子线程吗?</h2><p>可以的，将修改对象属性过程放在子线程内执行,在监听回调方法内获取当前线程同样为子线程。故KVO的响应和KVO观察的值变化是在一个线程上的。从子线程发出的，接收就在子线程；从主线程发的接收就在主线程。但是刷新UI一定要在主线程。</p>
<h2 id="如何手动关闭kvo"><a href="#如何手动关闭kvo" class="headerlink" title="如何手动关闭kvo"></a>如何手动关闭kvo</h2><p><code>+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;</code><br>回调中对应的key返回NO。</p>
<h2 id="如何手动触发KVO？"><a href="#如何手动触发KVO？" class="headerlink" title="如何手动触发KVO？"></a>如何手动触发KVO？</h2><p>手动调用willChangeValueForKey:和didChangeValueForKey:</p>
<h2 id="通过KVC修改属性会触发KVO么-如果修改成变量的值呢？"><a href="#通过KVC修改属性会触发KVO么-如果修改成变量的值呢？" class="headerlink" title="通过KVC修改属性会触发KVO么?如果修改成变量的值呢？"></a>通过KVC修改属性会触发KVO么?如果修改成变量的值呢？</h2><p>可以，KVO的本质就是在调用属性的set方法才触发了KVO，如果直接修改成员变量的值，就不会触发set方法，所以也不会触发KVO。</p>
<h2 id="哪些情况下使用kvo会崩溃，怎么防护崩溃"><a href="#哪些情况下使用kvo会崩溃，怎么防护崩溃" class="headerlink" title="哪些情况下使用kvo会崩溃，怎么防护崩溃"></a>哪些情况下使用kvo会崩溃，怎么防护崩溃</h2><p>1.KVO 添加次数和移除次数不匹配：<br>移除了未注册的观察者，导致崩溃。<br>重复移除多次，移除次数多于添加次数，导致崩溃。<br>重复添加多次，虽然不会崩溃，但是发生改变时，也同时会被观察多次。<br>2.被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃。 例如：被观察者是局部变量的情况（iOS 10 及之前会崩溃）。<br>3.添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context: 方法，导致崩溃。<br>4.添加或者移除时 keypath == nil，导致崩溃。<br>5.防护是封装好，防止重复添加和删除，并dealloc前移除。</p>
<h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><h2 id="怎么理解Objective-C是动态运行时语言。"><a href="#怎么理解Objective-C是动态运行时语言。" class="headerlink" title="怎么理解Objective-C是动态运行时语言。"></a>怎么理解Objective-C是动态运行时语言。</h2><p>主要是将数据类型的确定和函数的调用由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。</p>
<p>1.运行时：简单来说, 运行时机制使我们直到运行时才去确定数据类型和要调用的函数。</p>
<p>2.多态:不同对象以自己的方式响应相同的消息的能力叫做多态。</p>
<h2 id="Runtime-如何实现-weak-属性"><a href="#Runtime-如何实现-weak-属性" class="headerlink" title="Runtime 如何实现 weak 属性"></a>Runtime 如何实现 weak 属性</h2><ul>
<li><p>首先要搞清楚weak属性的特点<br>weak策略表明该属性定义了一种“非拥有关系” (nonowning relationship)。 为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似; 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)</p>
</li>
<li><p>那么Runtime如何实现weak变量的自动置nil？<br>Runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法， 假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为 nil。</p>
</li>
</ul>
<h2 id="下面的代码输出什么？"><a href="#下面的代码输出什么？" class="headerlink" title="下面的代码输出什么？"></a>下面的代码输出什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>答案：都输出 Son<br>这个题目主要是考察关于objc中对 self 和 super 的理解：</p>
<ul>
<li>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 本质是一个编译器标示符，和 self 是指向的同一个消息接受者</li>
<li>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；</li>
<li>而当使用 super时，则从父类的方法列表中开始找。然后调用父类的这个方法</li>
<li>调用[self class] 时，会转化成 objc_msgSend函数<br>id objc_msgSend(id self, SEL op, …)</li>
<li>调用 [super class]时，会转化成 objc_msgSendSuper函数<br>id objc_msgSendSuper(struct objc_super *super, SEL op, …)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">  __unsafe_unretained id receiver;</span><br><span class="line">  __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>* 第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数self
* 第二个成员是记录当前类的父类是什么，告诉程序从父类中开始找方法，找到方法后，最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用， 此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son</code></pre>
<h2 id="简述下Objective-C中调用方法的过程？"><a href="#简述下Objective-C中调用方法的过程？" class="headerlink" title="简述下Objective-C中调用方法的过程？"></a>简述下Objective-C中调用方法的过程？</h2><p>Objective-C是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下：<br>person实例对象发送一条test消息：<br>1.消息发送阶段：负责从类及父类的缓存列表及方法列表查找方法。每当调用方法的时候，会先去cache中查找是否有缓存的方法，如果没有缓存，在去类对象方法列表中遍历查找，如果方法不在列表里面；就会通过superclass找到父类的类对象，在去父类cache中查找是否有缓存的方法，如果没有缓存，去父类对象方法列表里面遍历查找，以此类推直到找到方法之后，就会将方法直接存储在cache中，下一次在调用这个方法的时候，就会在类对象的cache里面找到这个方法，直接调用了。</p>
<p>2.动态方法解析：如果消息<br>发送阶段没有找到方法，则会进入动态解析阶段，负责动态的添加方法实现。<br>动态解析对象方法时，会调用<br><code>态解析对象方法时，会调用 +(BOOL)resolveInstanceMetho</code><br>动态解析类方法时，会调用<br><code>+(BOOL)resolveClassMethod:(SEL)sel</code>方法。</p>
<p>3）快速转发阶段：如果也没有实现动态解析方法，则会进行消息转发阶段，将消息转发给可以处理消息的接受者来处理。以处理消息的接受者来处理。<br><code>- (id)forwardingTargetForSelector:</code>由上述代码可以看出，当本类没有实现方法，并且没有动态解析方法，就会调用forwardingTargetForSelector函数，进行消息转发，我们可以实现forwardingTargetForSelector函数，在其内部将消息转发给可以实现此方法的对象。</p>
<p>4）慢速转发阶段<br>`//方法签名：返回值类型、参数类型</p>
<ul>
<li>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br><code>如果forwardingTargetForSelector函数返回为nil或者没有实现的话，就会调用methodSignatureForSelector方法，用来返回一个方法签名，这也是我们正确跳转方法的最后机会。</code>//NSInvocation 封装了一个方法调用，包括：方法调用者，方法，方法的参数</li>
<li>(void)forwardInvocation:(NSInvocation *)anInvocation<br>`<br>如果methodSignatureForSelector方法返回正确的方法签名就会调用forwardInvocation方法，forwardInvocation方法内提供一个NSInvocation类型的参数，NSInvocation封装了一个方法的调用，包括方法的调用者，方法名，以及方法的参数。在forwardInvocation函数内修改方法调用对象即可。<br>如果methodSignatureForSelector返回的为nil，就会来到doseNotRecognizeSelector:方法内部，程序crash提示无法识别选择器unrecognized selector sent to instance。</li>
</ul>
<p>5）如果消息转发也没有实现，就会报方法找不到的错误，无法识别消息，unrecognzied selector sent to instance</p>
<h2 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a>runtime如何通过selector找到对应的IMP地址？</h2><p>1）class_getMethodImplementation(Class cls, SEL name);<br>2）method_getImplementation(Method m)</p>
<h2 id="super的本质？"><a href="#super的本质？" class="headerlink" title="super的本质？"></a>super的本质？</h2><p>1.分别打印的是什么？为什么一样？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;[self class]&#x3D;%@&quot;,[self class]); &#x2F;&#x2F;Student</span><br><span class="line">        NSLog(@&quot;[self superclass]&#x3D;%@&quot;,[self superclass]); &#x2F;&#x2F;Person</span><br><span class="line">        NSLog(@&quot;[super class]&#x3D;%@&quot;,[super class]); &#x2F;&#x2F;Student</span><br><span class="line">        NSLog(@&quot;[super superclass]&#x3D;%@&quot;,[super superclass]); &#x2F;&#x2F;Person</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码中可以发现无论是self还是super调用class或superclass的结果都是相同的。<br>为什么结果是相同的？super关键字在调用方法的时候底层调用流程是怎样的？<br>self ：当前方法的调用者,是一个指针<br>super：不是一个指针,编译指示器(标识符)，在程序编译时内部会做一些特殊处理 （底层会被编译成 objc_msgSendSuper()方法,super 的作用只是告诉编译器，查找方法的时候不用找自己的方法列表，直接从父类开始找。（调用者还是我自己）<br>superclass：是一个方法，返回的结果是调用者的父类对象<br>从底层来分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_msgSend(void &#x2F;* id self, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>objc_msgSend相对比较好理解，对应到这里，[self class] 就是 objc_msgSend（调用者（self），调用方法（@selecter（class）），….(其他参数)）</p>
<p>[super class] 中 objc_msgSendSuper() 的参数是一个objc_super结构体 结构体的第一个参数和objc_msgSend一样，也是receive（self），只是通过第二个参数 super_class 知道，方法从父类去找<br>可以理解为 objc_msgSendSuper(调用者（self），从哪开始找（super_class）,调用方法（@selecter（class）），….(其他参数))</p>
<p>2）再来一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 背景  Person：NSObject     Student：Person</span><br><span class="line">&#x2F;&#x2F;Person 声明并实现 readBook方法</span><br><span class="line">&#x2F;&#x2F;Person.h</span><br><span class="line">- (void)readBook;</span><br><span class="line">&#x2F;&#x2F;Person.m</span><br><span class="line">- (void)readBook&#123;</span><br><span class="line">    NSLog(@&quot;person readBook  self &#x3D; %@&quot;,NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Student 重写readBook</span><br><span class="line">- (void)readBook&#123;</span><br><span class="line">    &#x2F;&#x2F;调用者self - Student</span><br><span class="line">    [super readBook];</span><br><span class="line">    NSLog(@&quot;Student readbook&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化Studen 并调用readBook</span><br><span class="line">Student *s &#x3D; [Student new];</span><br><span class="line"> [s readBook];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//先思考答应结果，再看运行结果<br>//打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person readBook  self &#x3D; Student</span><br><span class="line">Student readbook</span><br></pre></td></tr></table></figure>

<p>上面的代码中，在Person中的[self class] 中的self 依然是Student，因为最开始就说过，self是调用者，在这里是student调用了 readBook，所以，即使[self class]在Person，依然是Student</p>
<p>3)superclass<br>superclass：是一个方法，返回的结果是调用者的父类对象(有类方法和示例方法)</p>
<p><strong>6.能否向编译后的类中增加实例变量？能否向动态添加的类中增加实例变量？</strong><br>1）编译后的类,不能为他增加实例变量<br>编译前创建的类,已经完成了实例变量的布局,在具体分析RunTime的数据结构当中知道class_ro_t,因为是readonly,所以在编译后是无法修改的,所以编译后的类,不能为他增加实例变量<br>2）但是可以向动态添加的类中添加实例变量<br>因为在动态添加类的过程中,只要调用它的注册类对方法之前，完成实例变量的添加,就可以实现。</p>
<h2 id="isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？"><a href="#isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？" class="headerlink" title="isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？"></a>isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？</h2><p>1.isa是一个class类型的指针，其源码结构为isa_t的联合体，在类中以class对象存在，指向类的地址，大小为8字节。<br>实例对象的isa指向类对象，类对象的isa指针指向元类，元类的isa指针指向根元类，根元类的isa指针指向本身，形成一个封闭的内循环。<br>2.类型:isa 有两种类型<br>纯指针，指向内存地址<br>NON_POINTER_ISA，除了内存地址，还存有一些其他信息</p>
<h2 id="runtime具体应用"><a href="#runtime具体应用" class="headerlink" title="runtime具体应用"></a>runtime具体应用</h2><p>1.利用关联对象（AssociatedObject）给分类添加属性<br>2.遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）<br>3.交换方法实现（交换系统的方法）<br>4.利用消息转发机制解决方法找不到的异常问题<br>5.KVC 字典转模型</p>
<h2 id="class-copyIvarList-amp-class-copyPropertyList区别？"><a href="#class-copyIvarList-amp-class-copyPropertyList区别？" class="headerlink" title="class_copyIvarList &amp; class_copyPropertyList区别？"></a>class_copyIvarList &amp; class_copyPropertyList区别？</h2><p>1.class_copyIvarList：可以获取类的属性列表以及成员变量列表<br>2.class_copyPropertyList：只能获取类的属性列表</p>
<h2 id="class-rw-t-和-class-ro-t-的区别？"><a href="#class-rw-t-和-class-ro-t-的区别？" class="headerlink" title="class_rw_t 和 class_ro_t 的区别？**"></a>class_rw_t 和 class_ro_t 的区别？**</h2><p>1.class_rw_t结构体内有一个指向 class_ro_t结构体的指针。<br>2.每个类都对应有一个class_ro_t结构体和一个class_rw_t结构体。<br>3.在编译期间，class_ro_t结构体就已经确定，在runtime运行之后，会生成class_rw_t结构体，。<br>4.他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定。</p>
<h2 id="category-amp-extension区别，能给NSObject添加Extension吗，结果如何？"><a href="#category-amp-extension区别，能给NSObject添加Extension吗，结果如何？" class="headerlink" title="category &amp; extension区别，能给NSObject添加Extension吗，结果如何？"></a>category &amp; extension区别，能给NSObject添加Extension吗，结果如何？</h2><p>1.extension 在编译期决定，它就是类的一部分，在编译期和头文件里的 @interface 以及实现文件里的 @implement 一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension，所以你无法为系统的类比如 NSString 添加 extension。</p>
<p>2.但是 category 则完全不一样，它是在运行期决定的。就 category 和 extension 的区别来看，我们可以推导出一个明显的事实，extension 可以添加实例变量，而 category 是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
<h2 id="为什么要设计metaclass"><a href="#为什么要设计metaclass" class="headerlink" title="为什么要设计metaclass"></a>为什么要设计metaclass</h2><p>符合程序设计的原则，单一职责原则</p>
<h2 id="我们常见的crash有哪些？如何处理？"><a href="#我们常见的crash有哪些？如何处理？" class="headerlink" title="我们常见的crash有哪些？如何处理？"></a>我们常见的crash有哪些？如何处理？</h2><ul>
<li>unrecognized selector crash </li>
</ul>
<p>1.(没找到对应的函数)unrecognizerecognized selector类型的crash在app众多的crash类型中占着比较大的成分，通常是因为一个对象调用了一个不属于它方法的方法导致的。<br>1)首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应的函数。<br>2)如果没找到在对象的类方法列表中找调用的方法，如果找到，转向相应的实现执行。<br>3)如果没有找到，去父类指针指向的对象中执行1，2<br>4)以此类推，如果一直到根类还没有找到，转向拦截调用，走消息转发<br>5）如果没有重写拦截调用的方法，程序报错。<br>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写NSObject的四个方法来处理:<br><code>+ (BOOL)resolveClassMethod:(SEL)sel; //动态类方法决议机制,决议类方法</code><br><code>+ (BOOL)resolveInstanceMethod:(SEL)sel;//动态的对象方法决议，决议对象方法</code><br>后两个方法需要转发到其他的类处理<br><code>- (id)forwardingTargetForSelector:(SEL)aSelector;//转发给其他的一个对象处理函数</code><br><code>- (void)forwardInvocation:(NSInvocation *)anInvocation;//灵活的将目标函数以其他形式执行</code></p>
<p>2.拦截调用的整个流程即Objective——C的消息转发机制。其具体流程<br>runtime提供了3种方式去补救：<br>1）调用resolveInanceMethod给个机会让类添加这个实现这个函数<br>2）调用forwardingTargetForSelector让别的对象去执行这个函数<br>3）调用forwardInvocation(函数执行器)灵活的将目标函数以及其他形式执行。<br>4）如果都不行，系统才会调用doesNotRecognizeSelector抛出异常。</p>
<p>3.既然可以补救，我们完全也可以利用消息转发机制来做文章，但是我们选择哪一步比较合适呢？<br>1)esolveInstanceMethod需要在类的本身动态的添加它本身不存在的方法，这些方法对于该类本身来说是冗余的。<br>2)forwardInvocation可以通过NSInvocation的形式将消息转发给多个对象，但是其开销比较大，需要创建新的。<br>3)NSInvocation对象，并且forwardInvocation的函数经常被使用者调用来做消息的转发选择机制，不适合多次重写。<br>4）forwardingTargetForSelector可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写。</p>
<ul>
<li>KVO类型crash</li>
</ul>
<p>1.observer没有实现observerValueKeyPath方法，crash<br>2.forKeyPath == nil,crash<br>3.多次移除,crash<br>可以让观察对象持有一个KVO的delegate,所有和KVO相关的操作均通过delegate来进行管理，delegate通过<br>首先为 NSObject 建立一个分类，利用 Method Swizzling，实现自定义的 BMP_addObserver:forKeyPath:options:context:、BMP_removeObserver:forKeyPath:、BMP_removeObserver:forKeyPath:context:、BMPKVO_dealloc 方法，用来替换系统原生的添加移除观察者方法的实现。<br>然后在观察者和被观察者之间建立一个 KVODelegate 对象，两者之间通过 KVODelegate 对象 建立联系。然后在添加和移除操作时，将 KVO 的相关信息例如 observer、keyPath、options、context 保存为 KVOInfo 对象，并添加到 KVODelegate 对象 中对应 的 关系哈希表 中，对应原有的添加观察者。<br>关系哈希表的数据结构：{keypath : [KVOInfo 对象1, KVOInfo 对象2, … ]}<br>在添加和移除操作的时候，利用  KVODelegate 对象 做转发，把真正的观察者变为 KVODelegate 对象，而当被观察者的特定属性发生了改变，再由 KVODelegate 对象 分发到原有的观察者上。<br>添加观察者时：通过关系哈希表判断是否重复添加，只添加一次。<br>移除观察者时：通过关系哈希表是否已经进行过移除操作，避免多次移除。<br>观察键值改变时：同样通过关系哈希表判断，将改变操作分发到原有的观察者上。</p>
<ul>
<li>NSNotification crash<br>当一个对象添加了notification之后，如果dealloc的时候，仍然持有notification，就会出现NSNotification类型的crash，NSNotification类型的crash多产生于程序员写代码时候犯疏忽，在NSNotificationCenter添加一个对象为observer之后，忘记了在对象dealloc的时候移除它。<br>所幸的是，苹果在iOS9之后专门针对于这种情况做了处理，所以在iOS9之后，即使开发者没有移除observer，Notification crash也不会再产生了。<br>不过针对于iOS9之前的用户，我们还是有必要做一下NSNotification Crash的防护的。<br>NSNotification Crash的防护原理很简单， 利用method swizzling hook NSObject的dealloc函数，再对象真正dealloc之前先调用一下：</li>
</ul>
<p>[[NSNotificationCenter defaultCenter] removeObserver:self]，即可。</p>
<ul>
<li>NSTimer crash 产生原因<br>在程序开发过程中，大家会经常使用定时任务，但使用NSTimer的 scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: 接口做重复性的定时任务时存在一个问题：NSTimer会 强引用 target实例，所以需要在合适的时机invalidate 定时器，否则就会由于定时器timer强引用target的关系导致 target不能被释放，造成内存泄露，甚至在定时任务触发时导致crash。 crash的展现形式和具体的target执行的selector有关。<br>与此同时，如果NSTimer是无限重复的执行一个任务的话，也有可能导致target的selector一直被重复调用且处于无效状态，对app的CPU，内存等性能方面均是没有必要的浪费。<br>当你在ViewController(简称VC)中使用timer属性，由于VC强引用timer，timer的target又是VC造成循环引用。当你在VC的dealloc方法中销毁timer，发现VC被pop，VC的dealloc方法没走，VC在等timer释放才走dealloc，timer释放在dealloc中，所以引起循环引用。</li>
</ul>
<p>1：使用block进行解决<br>定时器在执行时，将自身作为参数传递给block，来帮助避免循环引用</p>
<p>2：使用NSProxy进行解决<br>通过PFProxy这个伪基类（相当于ViewController1的复制类），继承NSProxy，避免直接让timer和viewController造成循环。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>1、什么特点？<br>1）继承：每一个类只能有一个基类，子类自动继承基类的：<br>    实例变量<br>    属性<br>    实例方法<br>    类方法<br>2）类的根类：NSObject</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="协议中可以定义-property么？"><a href="#协议中可以定义-property么？" class="headerlink" title="协议中可以定义@property么？"></a>协议中可以定义@property么？</h2><p>1.协议中不能定义成员变量、属性，只能定义方法。<br>2.如果定义了，报警告，如果必须定义的话，就需要去实现：<br>第一种方法@synthesize name<br>第二种方法实现set和get方法</p>
<h1 id="category和extension的作用？分两类和扩展的区别？"><a href="#category和extension的作用？分两类和扩展的区别？" class="headerlink" title="category和extension的作用？分两类和扩展的区别？"></a>category和extension的作用？分两类和扩展的区别？</h1><p>1.概念</p>
<ul>
<li>分类表示一个指向分类的结构体的指针。原则上它只能增加方法，不能增加成员（实例）变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;Instance variables may not be placed in categories</span><br><span class="line">    int age;&#x2F;&#x2F;报错分类中不能添加实例变量</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;属性：可以添加属性，但是不会自动生成实例变量_name和setter和getter方法</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">&#x2F;&#x2F;可以添加方法</span><br><span class="line">- (void)run;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩展主要用来为一个类添加额外的原来没有的实例变量，方法和属性。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。<br>类扩展中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person ()&#123;</span><br><span class="line">    int age;&#x2F;&#x2F;实例变量</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * name;&#x2F;&#x2F;属性</span><br><span class="line">- (void)run;&#x2F;&#x2F;方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self run];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)run&#123;</span><br><span class="line">    self-&gt;age &#x3D; 30;</span><br><span class="line">    self.name &#x3D; @&quot;zj&quot;;</span><br><span class="line">    NSLog(@&quot;%d --- %@&quot;,self-&gt;age,self.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.category和extension的区别：</p>
<ul>
<li><p>extension和category都可以添加属性，但是category的属性不能生成成员变量和getter、setter方法的实现。</p>
</li>
<li><p>extension可以添加实例变量，而category是无法添加实例变量。<br>因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。</p>
</li>
<li><p>extension在编译期决议（就是类的一部分），category在运行期决议。<br>extension在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，extension伴随类的产生而产生，亦随之一起消亡。</p>
</li>
<li><p>类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。</p>
</li>
<li><p>category可以给系统提供的类添加分类。</p>
</li>
</ul>
<p>3.分类的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name; &#x2F;&#x2F;名字</span><br><span class="line">    classref_t cls; &#x2F;&#x2F;类的引用</span><br><span class="line">    struct method_list_t *instanceMethods; &#x2F;&#x2F;实例方法列表</span><br><span class="line">    struct method_list_t *classMethods; &#x2F;&#x2F;类方法列表</span><br><span class="line">    struct protocol_list_t *protocols;  &#x2F;&#x2F;协议列表</span><br><span class="line">    struct property_list_t *instanceProperties; &#x2F;&#x2F;实例属性列表</span><br><span class="line">    &#x2F;&#x2F; Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties; &#x2F;&#x2F;类属性列表</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">    </span><br><span class="line">    protocol_list_t *protocolsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return nullptr;</span><br><span class="line">        else return protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Category的实现原理，以及Category为什么只能加方法不能加属性"><a href="#Category的实现原理，以及Category为什么只能加方法不能加属性" class="headerlink" title="Category的实现原理，以及Category为什么只能加方法不能加属性?"></a>Category的实现原理，以及Category为什么只能加方法不能加属性?</h2><p>分类的实现原理是将category中的方法、协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。<br>Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。</p>
<h2 id="Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？？"><a href="#Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？？" class="headerlink" title="Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？？"></a>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？？</h2><p>Category中有load方法，load方法在程序启动装载类信息的时候就会调用。load方法可以继承。调用子类的load方法之前，会先调用父类的load方法。</p>
<h2 id="load、initialize的区别，以及它们在category重写的时候的调用的次序？"><a href="#load、initialize的区别，以及它们在category重写的时候的调用的次序？" class="headerlink" title="load、initialize的区别，以及它们在category重写的时候的调用的次序？"></a>load、initialize的区别，以及它们在category重写的时候的调用的次序？</h2><p>区别在于调用方式和调用时刻<br>调用方式：load是根据函数地址直接调用，initialize是通过objc_msgSend调用<br>调用时刻：load是runtime加载类、分类的时候调用<br>                  initialize是类第一次接收到消息的时候调用<br>调用顺序：父类的load &gt; 类load &gt; 分类中load(多个分类：先编译的分类优先调用load方法)。<br>           先调父类initialize -&gt; 再调子类initialize。<br>           如果有分类：父类initialize -&gt; 分类+initialize，分类覆盖类的+initialize。</p>
<h2 id="普通方法的调用顺序"><a href="#普通方法的调用顺序" class="headerlink" title="普通方法的调用顺序?"></a>普通方法的调用顺序?</h2><p>只有父类和本类：调本类<br>如果有父类和本类和分类：只调用最后编译的分类run</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="iOS开发中有多少类型的线程？分别对比"><a href="#iOS开发中有多少类型的线程？分别对比" class="headerlink" title="iOS开发中有多少类型的线程？分别对比"></a>iOS开发中有多少类型的线程？分别对比</h2><p>1.pthread：一套用于C的多线程API、适用于 Unix / Linux / Windows 等系统、跨平台\可移植、使用难度大<br>2.NSThread：使用更加面向对象、简单易用，可直接操作线程对象<br>3.GCD：旨在替代NSThread等线程技术、充分利用设备的多核、基于 C 的底层的 API<br>4.NSOperation：是基于 GCD 实现的 Objective-C API</p>
<h2 id="GCD有哪些队列，默认提供哪些队列"><a href="#GCD有哪些队列，默认提供哪些队列" class="headerlink" title="GCD有哪些队列，默认提供哪些队列"></a>GCD有哪些队列，默认提供哪些队列</h2><p>主队列：dispatch_get_main_queue<br>全局队列：dispatch_get_global_queue<br>串行队列：dispatch_queue_create(“queue”, DISPATCH_QUEUE_SERIAL);<br>并发队列：dispatch_queue_create(“queue”, DISPATCH_QUEUE_CONCURRENT);</p>
<h2 id="GCD中的Block是在堆上还是栈上？"><a href="#GCD中的Block是在堆上还是栈上？" class="headerlink" title="GCD中的Block是在堆上还是栈上？"></a>GCD中的Block是在堆上还是栈上？</h2><p>堆上。可以通过block的isa指针确认。</p>
<h2 id="GCD有哪些方法api"><a href="#GCD有哪些方法api" class="headerlink" title="GCD有哪些方法api"></a>GCD有哪些方法api</h2><p>1.dispatch_queue_create  //通过dispatch_queue_create函数可生成Dispatch Queue<br>2.dispatch_after    //想在指定时间后执行处理的情况，可使用dispatch_after函数来实现。<br>3.Dispatch Group  //在追加到Dispatch Queue中的多个处理全部结束后想执行结束处理。<br>4.dispatch_barrier_async //dispatch_barrier_async函数会等待追加到Concurrent Dispatch Queue 上的并行执行的处理全部结束之后，再将指定的处理追加到该Concurrent Dispatch Queue中然后在由dispatch_barrier_async函数追加的处理执行完毕后，Concurrent Dispatch Queue才恢复为一般的动作。追加到该Concurrent Dispatch Queue的处理又开始并行执行。<br>5.dispatch_sync  //将指定的block同步追加到指定的Dispatch Queue中。在追加block结束之前，dispatch_sync函数会一直等待。<br>6.dispatch_once     //dispatch_once函数是保证在应用程序执行中只执行一次指定处理的API<br>7.dispatch_suspend / dispatch_resume            //dispatch_suspend函数挂起指定的Dispatch Queue；dispatch_resume函数恢复指定的Dispatch Queu</p>
<h2 id="GCD主线程-amp-主队列的关系"><a href="#GCD主线程-amp-主队列的关系" class="headerlink" title="GCD主线程 &amp; 主队列的关系"></a>GCD主线程 &amp; 主队列的关系</h2><p>主队列是一个任务执行队列，是一个线性队列，每个node是一个task，主线程在空闲时会去主队列里看看有没有要执行的任务，pop出来执行</p>
<h2 id="如何实现同步，有多少方式就说多少"><a href="#如何实现同步，有多少方式就说多少" class="headerlink" title="如何实现同步，有多少方式就说多少"></a>如何实现同步，有多少方式就说多少</h2><p>OSSpinLock<br>os_unfair_lock<br>pthread_mutex<br>dispatch_semaphore<br>NSLock<br>NSRecursiveLock<br>NSCondition<br>NSConditionLock<br>asynchronized</p>
<h2 id="dispatch-once实现原理"><a href="#dispatch-once实现原理" class="headerlink" title="dispatch_once实现原理"></a>dispatch_once实现原理</h2><p>定义一个dispatch_once_t的静态变量，标识下面的diapatch_once的block是否执行过了，static修饰会默认将onceToken其初始化为0，当值为0时才会执行block代码块里面的内容，此时onceToken不为0，当block执行完成，底层会将oneceToken设置为-1，以后再调用的话不会再走block代码块。</p>
<h2 id="什么情况下会死锁"><a href="#什么情况下会死锁" class="headerlink" title="什么情况下会死锁"></a>什么情况下会死锁</h2><p>通常指有两个线程T1和T2都卡住了，并等待对方完成某些操作。T1不能完成是因为它在等待T2完成。但T2也不能完成，因为它在等待T1完成。于是大家都完不成，就导致了死锁（DeadLock）。</p>
<h2 id="有哪些类型的线程锁，分别介绍下作用和使用场景"><a href="#有哪些类型的线程锁，分别介绍下作用和使用场景" class="headerlink" title="有哪些类型的线程锁，分别介绍下作用和使用场景"></a>有哪些类型的线程锁，分别介绍下作用和使用场景</h2><p>1）OSSpinLock (自旋锁)<br>2）os_unfair_lock(互斥锁)<br>3）dispatch_semaphore (信号量)<br>4）pthread_mutex(互斥锁)<br>5）NSLock(互斥锁、对象锁)<br>6）NSCondition(条件锁、对象锁)<br>7）NSRecursiveLock(递归锁、对象锁)<br>8）asynchronized()递归锁<br>9）pthread_mutex(recursive)(递归锁)<br>性能总结<br>OSSpinLock                          0.097348s<br>dispatch_semaphore                  0.155043s<br>os_unfair_lock                      0.171789s<br>pthread_mutex                       0.262592s<br>NSLock                              0.283196s<br>pthread_mutex(recursive)            0.372398s<br>NSRecursiveLock                     0.473536s<br>NSConditionLock                     0.950285s<br>@synchronized                       1.101924s<br>注:建议正常锁功能用 pthread_mutex ,os_unfair_lock (适配低版本)<br>锁的注解<br>1）OSSpinLock 就是典型的自旋锁<br>自旋锁的特点是在没有获取到锁时既锁已经被添加,还没有被解开时.<br>OSSpinLock处于忙等状态,一直占用CPU资源,类似如下伪代码:<br>while(锁没解开);</p>
<p>关于优先级反转问题<br>由于线程调度,每条线程的分配时间权重不一样,当权重小的线程先进入OSSpinLock优先加锁,<br>当权重大的线程再来访问,就阻塞在这,可能权重大的线程会一直分配到cpu所以一直会进来,<br>但是因为有锁,只能等待,权重小的线程得不到cpu资源分配,所以不会解锁,造成一定程度的死锁.<br>2）互斥锁<br>os_unfair_lock 、pthread_mutex是典型的互斥锁,在没有获取到锁时既锁已经被添加,还没有被解开时.<br>它们都会让当前线程进入休眠状态既不占用CPU资源,但是为什么,互斥锁比自旋锁的效率低呢,<br>是因为休眠,以及唤醒休眠,比忙等更加消耗CPU资源.</p>
<p>NSLock 封装的pthread_mutex的PTHREAD_MUTEX_NORMAL 模式<br>NSRecursiveLock 封装的pthread_mutex的PTHREAD_MUTEX_RECURSIVE 模式<br>3）条件锁<br>在一定条件下,让其等待休眠,并放开锁,等接收到信号或者广播,会从新唤起线程,并重新加锁.<br>pthread_cond_wait(&amp;_cond, &amp;_mutex);<br> // 信号<br>    pthread_cond_signal(&amp;_cond);<br> // 广播<br>    pthread_cond_broadcast(&amp;_cond);<br>像NSCondition封装了pthread_mutex的以上几个函数<br>NSConditionLock封装了NSCondition<br>4）递归锁<br>递归锁的主要意思是,同一条线程可以加多把锁.什么意思呢,就是相同的线程访问一段代码,<br>如果是加锁的可以继续加锁,继续往下走,不同线程来访问这段代码时,发现有锁要等待所有锁解开之后才可以继续往下走.<br>NSRecursiveLock 封装的pthread_mutex  的PTHREAD_MUTEX_RECURSIVE模式</p>
<h2 id="NSOperationQueue中的maxConcurrentOperationCount默认值"><a href="#NSOperationQueue中的maxConcurrentOperationCount默认值" class="headerlink" title="NSOperationQueue中的maxConcurrentOperationCount默认值"></a>NSOperationQueue中的maxConcurrentOperationCount默认值</h2><p>答案：-1</p>
<h2 id="NSTimer、CADisplayLink、dispatch-source-t-的优劣"><a href="#NSTimer、CADisplayLink、dispatch-source-t-的优劣" class="headerlink" title="NSTimer、CADisplayLink、dispatch_source_t 的优劣"></a>NSTimer、CADisplayLink、dispatch_source_t 的优劣</h2><p>1）NSTimer<br>    存在延迟<br>    必须加入Runloop<br>    容易出现循环引用<br>2）CADisplayLink<br>CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。<br>3）dispatch_source_t<br>时间准确<br>可以使用子线程，解决定时间跑在主线程上卡UI问题<br>需要将dispatch_source_t timer设置为成员变量，不然会立即释放</p>
<h2 id="有a，b，c3个网络请求，，在a请求完成后，b发起请求，b完成后c发起请求，在c结束时获得一个通知。这相当于多线程同步以及依赖，怎么实现？"><a href="#有a，b，c3个网络请求，，在a请求完成后，b发起请求，b完成后c发起请求，在c结束时获得一个通知。这相当于多线程同步以及依赖，怎么实现？" class="headerlink" title="有a，b，c3个网络请求，，在a请求完成后，b发起请求，b完成后c发起请求，在c结束时获得一个通知。这相当于多线程同步以及依赖，怎么实现？"></a>有a，b，c3个网络请求，，在a请求完成后，b发起请求，b完成后c发起请求，在c结束时获得一个通知。这相当于多线程同步以及依赖，怎么实现？</h2><p>1.GCD的实现方法：<br>1）GCD添加线程使用信号量添加线程依赖实例代码<br>2）特性<br>抽象的来讲，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程/进程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。</p>
<p>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)<br>如果信号量大于等于一时，做减一操作，然后往下执行。否则一直等下去（指放入阻塞队列），直到信号量大于等于一。</p>
<p>dispatch_semaphore_signal(semaphore)<br>释放资源，信号量加一操作</p>
<p>让线程一 线程二 线程三顺序执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcdDependTest3 &#123;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(0);  &#x2F;&#x2F; 信号量初始化为0</span><br><span class="line">    </span><br><span class="line">线程一做事情    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程一做事情&quot;);</span><br><span class="line">        for (int i  &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;just for delayed</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;dispatch1 semaphore send&quot;);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">线程二做事情    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程二做事情&quot;);</span><br><span class="line">        for (int i  &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;just for delayed</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;dispatch2 semaphore send&quot;);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">线程二做事情    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程三做事情&quot;);</span><br><span class="line">        for (int i  &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;just for delayed</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;dispatch3 semaphore send&quot;);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;function end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1)通过执行结果可知，通过信号量的确可以给 GCD线程添加依赖。<br>2)dispatch_semaphore_signal(semaphore)方法必须再另一个线程中调用<br>3)dispatch_semaphore_wait()一定不能在主线程中调用,因为一不小心就会阻塞当前线程,造成主线程卡死。</p>
<p>2.NSOperation的实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)depencyDemo&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *A &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----login&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *B &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----notifyUser&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *C &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----downLoad&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *D &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----pay&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *mainQueue &#x3D; [NSOperationQueue mainQueue];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;NSOperation,addDependency就是表示我这个任务,要依赖于哪个任务执行完</span><br><span class="line">    [C addDependency:B];</span><br><span class="line">    [B addDependency:A];</span><br><span class="line">    [D addDependency:C];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;YES,同步, 主队列千万不要和同步搞在一起</span><br><span class="line">    [mainQueue addOperations:@[A,B,C,D] waitUntilFinished:NO];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果A、B、C、D</p>
<h2 id="多线程在项目中的应用？"><a href="#多线程在项目中的应用？" class="headerlink" title="多线程在项目中的应用？"></a>多线程在项目中的应用？</h2><p>1.线程间的通信<br>当我们在子线程中执行耗时操作，需要切换回主线程刷新UI界面时，需要切换回主线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;刷新UI界面&quot;);</span><br><span class="line">    &#125;)；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.延迟函数-延迟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, int64_t (2.0*NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2秒后执行这里的操作&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>3.一次性函数-单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSLog(@&quot;在整个应用程序中只会运行一次&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="GCD、NSOperation和NSThread的区别和特点？"><a href="#GCD、NSOperation和NSThread的区别和特点？" class="headerlink" title="GCD、NSOperation和NSThread的区别和特点？"></a>GCD、NSOperation和NSThread的区别和特点？</h2><p>1.GCD<br>Grand Central Dispatch(GCD)是Apple开发的一个多核编程的解决方法。是一种更轻量级的，以FIFO(先进先出，后进后出)的顺序执行并发任务。使用GCD我们并不用关心任务的调度情况，而是系统会自动帮我们处理。<br>1）优点：最高效，避开并发陷阱。<br>2）缺点：基于C实现。</p>
<p>2.NSOperation<br>NSOperation是对GCD面向对象的ObjC封装，但是相比GCD基于C语言开发，效率却更高，建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD<br>1）优点：自带线程周期管理，操作上可更注重自己逻辑。<br>2）缺点：面向对象的抽象类，只能实现它或者使用它定义好的两个子类：NSInvocationOperation和NSBlockOperation进行创建和操作，可以设置最大并发线程数、在优先级控制方面做得很好，利用设置“依赖关系”即可满足，并且可以传递多个参数。</p>
<p>3.NSThread<br>每个NSThread对象对应一个线程，真正最原始的线程。<br>1）优点：NSThread轻量级最低，相对简单。<br>2）缺点：手动管理所有的线程活动，如生命周期、线程同步、睡眠等。。<br>3）nonatomic，非原子性，多线程访问修改不加锁。<br>atomic，原子性，多线程访问加锁。</p>
<p>4.GCD和NSOperation的区别：<br>1）GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便<br>2）GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序<br>3）NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂<br>4）NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）</p>
<h2 id="单例的优缺点"><a href="#单例的优缺点" class="headerlink" title="单例的优缺点"></a>单例的优缺点</h2><p>1.优点：<br>1)提供了应用唯一的实例对象，规范化统一管理资源，即提供了对唯一实例的受控访问。<br>2)不用再频繁地创建和销毁对象，从而提高了系统的性能和节约系统资源。<br>3)单例对象可以做到按需创建对象或加载资源，以节省不必要的内存。<br>4)避免对共享资源的多重占用</p>
<p>2.缺点：<br>1)单例从创建后到彻底关闭程序前都会一直存在，如果过多的创建单例无疑浪费系统资源和影响系统效率。<br>2)由于单利模式中没有抽象层接口，因此单例类很难再进行扩展。<br>3)单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>4)单例对象长时间不被利用，系统有可能会认为是垃圾而被回收，这将导致当前单例对象状态的丢失。</p>
<h2 id="copy和strong的区别"><a href="#copy和strong的区别" class="headerlink" title="copy和strong的区别"></a>copy和strong的区别</h2><p>1.什么是浅拷贝？什么是深拷贝？<br>浅拷贝：一般来说，A copy 之后得到 copyA ，然后我们在修改copyA的值得时候 A 会跟着变化我们称作浅拷贝。指向相同的内存地址。<br>深拷贝：深拷贝就是 A copy 之后得到 copyA，在我们修改copyA的值的时候，两个实例不会相互影响。指向不同的内存地址。</p>
<p>2.为什么日常开发NSString属性用copy修饰？<br>例如用一个可变字符串A给用copy修饰的属性B赋值则A再次拼接改变的时候, B的值不会变,因为copy出来一块新的内存区域; 而用strong修饰的时候A改变时B也会跟着改变,因为strong强行引用指针,是同一块内存区域</p>
<p>3.为什么日常开发NSMutableString属性用strong修饰?<br>用copy修饰的时候其实拷贝出来的一块内存区域是不可变, 用一个可变字符串给他赋值, 然后拼接这个属性时就会崩溃, 用strong修饰的时候就不会出现这种情况, 因为strong修饰后是指针强引用, 始终指向的同一块内存区域</p>
<p>4.为什么日常开发NSArray属性用copy修饰?<br>如果用strong修饰的话,用一个可变数组给他赋值,然后可变数组改变后,这个NSArray内容也会跟着改变,这明显有违背NSArray原则, 但是用copy修饰的话这时用可变数组给其赋值,相当于是重新拷贝了一份内存区域;</p>
<p>5.为什么日常开发NSMutableArray属性用strong修饰?<br>类似于NSMutableString的问题,如果用copy修饰这个数组,相当于copy了一份不可边的内存区域, 你对他更改的时候就会crash</p>
<p>6、copy、strong、weak的区别？<br>可变变量中，copy是重新开辟一个内存，strong，weak，assgin后三者不开辟内存，只是指针指向原来保存值的内存的位置，storng指向后会对该内存引用计数+1，而weak，assgin不会。weak，assgin会在对象释放的时候，weak会将内存值设为nil，assign不会，assign在内存没有被重写前依旧可以输出，但一旦被重写将出现奔溃</p>
<p>不可变变量中，因为值本身不可被改变，copy没必要开辟出一块内存存放和原来内存一模一样的值，所以内存管理系统默认都是浅拷贝。其他和可变变量一样，如weak修饰的变量同样会在内存引用计数为0时变为nil。</p>
<p>7.delegate为什么要用weak或者assign而不用strong？</p>
<p>a创建对象b,b中有C类对象c，所以a对b有一个引用,b对c有一个引用，a.b引用计数分别为1，1。当c.delegate = b的时候，实则是对b有了一个引用，如果此时c的delegate用strong修饰则会对b的值内存引用计数+1，b引用计数为2。当a的生命周期结束，随之释放对b的引用，b的引用计数变为1，导致b不能释放，b不能释放又导致b对c的引用不能释放，c引用计数还是为1，这样就造成了b和c一直留在了内存中。</p>
<p>而要解决这个问题就是使用weak或者assign修饰delegate，这样虽然会有c仍然会对b有一个引用，但是引用是弱引用，当a生命周期结束的时候，b的引用计数变为0，b释放后随之c的引用消失，c引用计数变为0，释放。</p>
<h2 id="Notification通知"><a href="#Notification通知" class="headerlink" title="Notification通知"></a>Notification通知</h2><p>1.NSNotificationCenter是同步的还是异步的？<br>同步的：接收通知和发送通知时所在线程一致，和监听时所在线程无关。</p>
<p>2.NSNotification和delegate的区别？<br>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；<br>效率：Delegate比NSNOtification高；</p>
<h2 id="Delegate和Block区别"><a href="#Delegate和Block区别" class="headerlink" title="Delegate和Block区别"></a>Delegate和Block区别</h2><p>Delegate和Block一般是一对一的通信；<br>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；<br>Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；</p>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>1、计时器的种类？<br>NSTimer、CADisplayLink、dispatch_source_t</p>
<p>2、NSTimer使用、特性？<br>注意 :<br>调用创建方法后，target对象的计数器会加1，直到执行完毕，自动减1。如果是循环执行的话，就必须手动关闭，否则可以不执行释放方法。</p>
<p>特性：<br>存在延迟<br>不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。<br>必须加入Runloop</p>
<p>使用上面的创建方式，会自动把timer加入MainRunloop的NSDefaultRunLoopMode中。如果使用以下方式创建定时器，就必须手动加入Runloop:<br>NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];<br>[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</p>
<p>3、CADisplayLink<br>解释：<br>当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p>
<p>特性：<br>屏幕刷新时调用CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒<br>延迟iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>
<p>使用场景：<br>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</p>
<p>4、dispatch_source_t<br>特性：<br>默认是重复执行的，可以在事件响应回调中通过dispatch_source_cancel方法来设置为只执行一次，如下代码:</p>
<p>优点：<br>时间准确<br>可以使用子线程，解决定时间跑在主线程上卡UI问题<br>注意事项：<br>需要将dispatch_source_t timer设置为成员变量，不然会立即释放<br>默认是重复执行的，可以在事件响应回调中通过dispatch_source_cancel方法来设置为只执行一次，如下代码:</p>
<h2 id="UIView和CALayer"><a href="#UIView和CALayer" class="headerlink" title="UIView和CALayer"></a>UIView和CALayer</h2><p>1.UIView和CALayer的关系？<br>1）UIView继承UIReponder，CALayer继承NSObject。<br>2）UIView响应事件，CALayerUI。<br>3）UIView是CALayer的代理。</p>
<p>2.UIWindow和UIView的关系？<br>1）UIWindow继承自UIView。<br>2）UIWindow提供一个区域用来显示UIView。</p>
<h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><p>1.简单聊聊 ARC 与 MRC？<br>苹果在 iOS 5 中引入了ARC（Automatic Reference Counting）自动引用计数内存管理技术，通过LLVM编译器和Runtime协作来进行自动管理内存。LLVM编译器会在编译时在合适的地方为 OC 对象插入retain、release和autorelease代码，省去了在MRC（Manual Reference Counting）手动引用计数下手动插入这些代码的工作，减轻了开发者的工作量。<br>在MRC下，当我们不需要一个对象的时候，要调用release或autorelease方法来释放它。调用release会立即让对象的引用计数减 1 ，如果此时对象的引用计数为 0，对象就会被销毁。调用autorelease会将该对象添加进自动释放池中，它会在一个恰当的时刻自动给对象调用release，所以autorelease相当于延迟了对象的释放。</p>
<h2 id="ARC-环境下，autorelease-对象在什么时候释放？回到我们最初的面试题，在ARC环境下，autorelease对象在什么时候释放？我们就分系统干预释放和手动干预释放两种情况回答。"><a href="#ARC-环境下，autorelease-对象在什么时候释放？回到我们最初的面试题，在ARC环境下，autorelease对象在什么时候释放？我们就分系统干预释放和手动干预释放两种情况回答。" class="headerlink" title="ARC 环境下，autorelease 对象在什么时候释放？回到我们最初的面试题，在ARC环境下，autorelease对象在什么时候释放？我们就分系统干预释放和手动干预释放两种情况回答。"></a>ARC 环境下，autorelease 对象在什么时候释放？回到我们最初的面试题，在ARC环境下，autorelease对象在什么时候释放？我们就分系统干预释放和手动干预释放两种情况回答。</h2><p>1.系统干预释放：在iOS工程中系统干预释放的autorelease对象的释放时机是由RunLoop控制的，会在当前RunLoop每次循环结束时释放。<br>iOS在主线程的RunLoop中注册了两个Observer。<br>第 1 个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()；<br>第 2 个Observer<br>① 监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()；<br>② 监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()。<br>kCFRunLoopEntry：在即将进入RunLoop时，会自动创建一个__AtAutoreleasePool结构体对象，并调用objc_autoreleasePoolPush()函数。<br>kCFRunLoopBeforeWaiting：在RunLoop即将休眠时，会自动销毁一个__AtAutoreleasePool对象，调用objc_autoreleasePoolPop()。然后创建一个新的__AtAutoreleasePool对象，并调用objc_autoreleasePoolPush()。<br>kCFRunLoopBeforeExit，在即将退出RunLoop时，会自动销毁最后一个创建的__AtAutoreleasePool对象，并调用objc_autoreleasePoolPop()</p>
<p>2.手动干预释放<br>添加进手动指定的@autoreleasepool中的autorelease对象，在@autoreleasepool大括号结束时就会释放，不受RunLoop控制。</p>
<p>3.AutoreleasePoolPage()<br>objc_autoreleasePoolPush()和objc_autoreleasePoolPop()两个函数其实是调用了AutoreleasePoolPage类的两个类方法push()和pop()。所以@autoreleasepool底层就是使用AutoreleasePoolPage类来实现的。</p>
<p>push操作是往自动释放池中添加一个POOL_BOUNDARY（哨兵），并返回它存放的内存地址；接着每有一个对象调用autorelease方法，会将它的内存地址添加进自动释放池中。<br>pop操作是传入一个POOL_BOUNDARY的内存地址，从最后一个入栈的autorelease对象开始，将自动释放池中的autorelease对象全部释放（实际上是给它们发送一条release消息），直到遇到这个POOL_BOUNDARY。</p>
<p>4.POOL_BOUNDARY<br>POOL_BOUNDARY的前世叫做POOL_SENTINEL，称为哨兵对象或者边界对象；<br>POOL_BOUNDARY用来区分不同的自动释放池，以解决自动释放池嵌套的问题；<br>每当创建一个自动释放池，就会调用push()方法将一个POOL_BOUNDARY入栈，并返回其存放的内存地址；<br>当往自动释放池中添加autorelease对象时，将autorelease对象的内存地址入栈，它们前面至少有一个POOL_BOUNDARY；<br>当销毁一个自动释放池时，会调用pop()方法并传入一个POOL_BOUNDARY，会从自动释放池中最后一个对象开始，依次给它们发送release消息，直到遇到这个POOL_BOUNDARY。</p>
<p>5.ARC 环境下，需不需要手动添加 @autoreleasepool？<br>AppKit 和 UIKit 框架会在RunLoop每次事件循环迭代中创建并处理@autoreleasepool，因此，你通常不必自己创建@autoreleasepool，甚至不需要知道创建@autoreleasepool的代码怎么写。但是，有些情况需要自己创建@autoreleasepool。</p>
<p>例如，如果我们需要在循环中创建了很多临时的autorelease对象，则手动添加@autoreleasepool来管理这些对象可以很大程度地减少内存峰值。比如在for循环中alloc图片数据等内存消耗较大的场景，需要手动添加@autoreleasepool。</p>
<p>苹果给出了三种需要手动添加@autoreleasepool的情况：</p>
<p>① 如果你编写的程序不是基于 UI 框架的，比如说命令行工具；<br>② 如果你编写的循环中创建了大量的临时对象；<br>你可以在循环内使用@autoreleasepool在下一次迭代之前处理这些对象。在循环中使用@autoreleasepool有助于减少应用程序的最大内存占用。<br>③ 如果你创建了辅助线程。<br>一旦线程开始执行，就必须创建自己的@autoreleasepool；否则，你的应用程序将存在内存泄漏。</p>
<h1 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h1><p>1、加载图片的流程<br>主要的三个类SDWebImageManager、SDWebImageDownloader、SDImageCache<br>1）入口 setImageWithURL:placeholderImage:options:<br>会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</p>
<p>2）进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:，<br>交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.</p>
<p>3）先从内存图片缓存查找是否有图片，<br>如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。</p>
<p>4）SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage:<br>到 UIImageView+WebCache 等前端展示图片。</p>
<p>5）如果内存缓存中没有，生成 NSInvocationOperation<br>添加到队列开始从硬盘查找图片是否已经缓存。</p>
<p>6）根据 URLKey 在硬盘缓存目录下尝试读取图片文件。<br>这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</p>
<p>7）如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中<br>（如果空闲内存过小，会先清空内存缓存）。<br>SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。<br>进而回调展示图片。</p>
<p>8）如果从硬盘缓存目录读取不到图片，<br>说明所有缓存都不存在该图片，需要下载图片，<br>回调 imageCache:didNotFindImageForKey:userInfo:。</p>
<p>9）共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</p>
<p>10）图片下载由 NSURLConnection 来做，<br>实现相关 delegate 来判断图片下载中、下载完成和下载失败。</p>
<p>11）connection:didReceiveData: 中<br>利用 ImageIO 做了按图片下载进度加载效果。</p>
<p>12）connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。</p>
<p>13）图片解码处理在一个 NSOperationQueue 完成，<br>不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，<br>最好也在这里完成，效率会好很多。</p>
<p>14）在主线程 notifyDelegateOnMainThreadWithInfo:<br>宣告解码完成，<br>imageDecoder:didFinishDecodingImage:userInfo:<br>回调给 SDWebImageDownloader。</p>
<p>15）imageDownloader:didFinishWithImage:<br>回调给 SDWebImageManager 告知图片下载完成。</p>
<p>16）通知所有的 downloadDelegates 下载完成，<br>回调给需要的地方展示图片。</p>
<p>17）将图片保存到 SDImageCache 中，<br>内存缓存和硬盘缓存同时保存。<br>写文件到硬盘也在以单独 NSInvocationOperation 完成，<br>避免拖慢主线程。</p>
<p>18）SDImageCache 在初始化的时候会注册一些消息通知，<br>在内存警告或退到后台的时候清理内存图片缓存，<br>应用结束的时候清理过期图片。</p>
<p>19）SDWI 也提供了 UIButton+WebCache 和<br>MKAnnotationView+WebCache，方便使用。<br>20）SDWebImagePrefetcher 可以预先下载图片，</p>
<p>2、缓存策略<br>它的底层是用NSCache在实现的,NSCache是Foundation框架提供的缓存类的实现，它是线程安全的。在内存不足时NSCache会自动释放存储的对象。key是不会重复的。<br>SDWebImage的缓存策略：缓存有关的一共有四个文件SDImageCacheConfig和SDImageCache，SDImageCacheConfig配置类，保存一些缓存策略的信息（压缩图片-YES、iCloud备份-关闭、内存做缓存-YES、最长时间默认1周、缓存占用最大的空间-字节），SDImageCache通过url作为key，UIImage作为value存到内存。并开启异步串行队列将图片编码存储到磁盘中defalut文件下，key未url做了MD5加密并拼接defalut路径为绝对路径。</p>
<h1 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h1><p>1.AFNetworking 底层原理分析<br>AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,<br>其中主要有以下类:<br>1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责<br>发送⽹络请求, 使⽤最多的⼀个类。(3.0废弃)<br>2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送⽹络请求,使<br>⽤最多的⼀个类。<br>3). AFNetworkReachabilityManager：实时监测⽹络状态的⼯具类。当前的⽹络环<br>境发⽣改变之后,这个⼯具类就可以检测到。<br>4). AFSecurityPolicy：⽹络安全的⼯具类, 主要是针对 HTTPS 服务。<br>5). AFURLRequestSerialization：序列化⼯具类,基类。上传的数据转换成JSON格 式 (AFJSONRequestSerializer).使⽤不多。<br>6). AFURLResponseSerialization：反序列化⼯具类;基类.使⽤⽐较多:<br>7). AFJSONResponseSerializer; JSON解析器,默认的解析器.<br>8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返<br>回⼆进<br>制数据.对服务器返回的数据不做任何处理.<br>9). AFXMLParserResponseSerializer; XML解析器;</p>
<h2 id="MJEetension"><a href="#MJEetension" class="headerlink" title="MJEetension"></a>MJEetension</h2><p>原理： 主要作用是将json -&gt; Model，主要分为三步<br>1.创建模型<br>2.为模型中的属性赋值<br>3.返回模型</p>
<ul>
<li>使用Runtime动态获取模型的类和其所有父类的所有的属性名（包括继承链的所有属性，MJExtension对模型的属性做了缓存，下次转换时自己使用，空间换时间）</li>
<li>将服务器返回的json数据转为字典，并根据属性名在数据字典中获取对应的值</li>
<li>将取出的值使用KVC（setValue:forKey）设置给Model即可</li>
</ul>
<p>1.主要是用runtime API是实现的数据解析，将字典转模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ***** 获取父类, 返回Class</span><br><span class="line">class_getSuperclass(Class _Nullable cls) </span><br><span class="line">&#x2F;&#x2F; ***** 获取属性列表, 返回数据类型 objc_property_t * 数组.</span><br><span class="line">class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)</span><br><span class="line">&#x2F;&#x2F; ***** 获取属性名,返回char *类型,可转为NSString.</span><br><span class="line">property_getName(objc_property_t _Nonnull property) </span><br><span class="line">&#x2F;&#x2F; 获取property的attribute,返回char *类型,可转为NSString. 用于获取property的类型</span><br><span class="line">property_getAttributes(objc_property_t _Nonnull property) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ***** 使用KVC给数据model的property赋值,value为字典中取出的数据, key为数据模型object的属性名.</span><br><span class="line">[object setValue:value forKey:key];</span><br></pre></td></tr></table></figure>

<h2 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h2><p>1.下拉刷新的基本原理<br>大部分的下拉刷新控件，都是用contentInset实现的。大部分的下拉刷新控件，都是将自己放在UIScrollView的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果<br>1）通过UIScrollView+MJRefresh里的一个category，为UIScrollView增加了属性header和footer。<br>2）通过KVO监听UIScrollView的contentOffset和contentSize实现状态监听<br>3）下拉的时候临时增大contentInset，令header保留在屏幕上。上拉同理。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>1.问题：10阶层楼梯，每次只能走一阶或两阶，问有多少种走法？</p>
<p>递归法</p>
<p>设F(n)是爬到n阶层的走法数，那么<br>F(10) = F(9) + F(8)<br>F(9) = F(8) + F(7)<br>…<br>F(3) = F(2) + F(1)<br>F(1) 为1中走法，F(2)为2种走法，故编程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int getClimbWays(int n) &#123;</span><br><span class="line">    if (n &lt; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return getClimbWays(n - 1) + getClimbWays(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算结果是89种，通过该方法就可以计算任意阶层的走法。<br>复杂度分析：<br>时间复杂度：O(2n)，因为每次调用都会执行该方法两次。这个复杂度随着n的增大，执行时间会急剧增加，故需要优化。</p>
<h2 id="问题：10阶楼梯，每次只能走一阶或亮阶或三阶，问有多少种走法？"><a href="#问题：10阶楼梯，每次只能走一阶或亮阶或三阶，问有多少种走法？" class="headerlink" title="问题：10阶楼梯，每次只能走一阶或亮阶或三阶，问有多少种走法？"></a>问题：10阶楼梯，每次只能走一阶或亮阶或三阶，问有多少种走法？</h2><p>递归法</p>
<p>设F(n)是爬到n阶层的走法数，那么<br>F(10) = F(9) + F(8) + F(7)</p>
<p>F(9) = F(8) + F(7) + + F(6)<br>…<br>F(3) = F(2) + F(1) + + F(0)<br>F(1) 为1中走法，F(2)为2种走法，F(3)为4种走法，故编程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int getClimbWays(int n) &#123;</span><br><span class="line">    if (n &lt; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; 3) &#123;</span><br><span class="line">        return 4;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &gt; 3) &#123;</span><br><span class="line">        return getClimbWays(n - 1) + getClimbWays(n - 2) + getClimbWays(n - 3) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>计算结果是89种，通过该方法就可以计算任意阶层的走法。<br>复杂度分析：</p>
<p>3.冒泡排序<br>//相邻两个进行比较，每一次能把最大值排位到最后 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr &#x3D; [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;4&quot;, nil];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.count - 1 - i; j ++) &#123;</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@“arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure>

<p>4.选择排序<br>//取第一个与剩下的所有进行比较，确定第一个最小的<br>//同理，取到第二个与剩下的比较，取到第二个最小的<br>//以此类推，排好序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr &#x3D; [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">            if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@“arr:%@&quot;,arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.快速排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)quickSortArray:(NSMutableArray *)array withLeftIndex:(NSInteger)leftIndex andRightIndex:(NSInteger)rightIndex</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;数组没有元素或这有一个元素时，返回</span><br><span class="line">    if (leftIndex &gt;&#x3D; rightIndex) &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;左边的下边</span><br><span class="line">    NSInteger i &#x3D; leftIndex;</span><br><span class="line">    &#x2F;&#x2F;右边的下标</span><br><span class="line">    NSInteger j &#x3D; rightIndex;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;记录比较基准数</span><br><span class="line">    NSInteger key &#x3D; [array[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        &#x2F;&#x2F;首先从右边j开始查找比基准数小的值</span><br><span class="line">        &#x2F;&#x2F;如果比基准数大，继续查找</span><br><span class="line">        while (i &lt; j &amp;&amp; [array[j] integerValue] &gt;&#x3D; key) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果比基准数小，则将查找到的小值调换到i的位置</span><br><span class="line">        array[i] &#x3D; array[j];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;当在右边查找到一个比基准数小的值时，就从i开始往后找比基准数大的值</span><br><span class="line">        &#x2F;&#x2F;如果比基准数小，继续查找</span><br><span class="line">        while (i &lt; j &amp;&amp; [array[i] integerValue] &lt;&#x3D; key) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果比基准数大，则将查找到的大值调换到j的位置</span><br><span class="line">        array[j] &#x3D; array[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将基准数放到正确位置</span><br><span class="line">    array[i] &#x3D; @(key);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;递归排序&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;排序基准数左边的</span><br><span class="line">    [self quickSortArray:array withLeftIndex:leftIndex andRightIndex:i - 1];</span><br><span class="line">    &#x2F;&#x2F;排序基准数右边的</span><br><span class="line">    [self quickSortArray:array withLeftIndex:i + 1 andRightIndex:rightIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6.递归求和1+2+..+n?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sum(n) &#x3D; sum(n-1) + n</span><br><span class="line">sum(n-1) &#x3D; sum(n-2) + n-1</span><br><span class="line">…</span><br><span class="line">    </span><br><span class="line">sum(2) &#x3D; sum(1) + 2; </span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>7.折半查找（二分查找） 折半查找：优化查找时间（不用遍历全部数据）<br>折半查找的原理： </p>
<ol>
<li>数组必须是有序的 </li>
<li>必须已知 min 和 max（知道范围） </li>
<li>动态计算 mid 的值，取出 mid 对应的值进行比较 </li>
<li>如果 mid 对应的值大于要查找的值，那么 max 要变小为 mid-1 </li>
<li>如果 mid 对应的值小于要查找的值，那么 min 要变大为 mid+1<br>// 已知一个有序数组, 和一个 key, 要求从数组中找到 key 对应的索引位置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr &#x3D; @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">    int key &#x3D; [@(5) intValue];</span><br><span class="line">    int min &#x3D; 0;</span><br><span class="line">    int max &#x3D; arr.count - 1;</span><br><span class="line">    int mid;</span><br><span class="line">    while (min &lt;&#x3D; max) &#123;</span><br><span class="line">        &#x2F;&#x2F;计算中间下标</span><br><span class="line">        mid &#x3D; (min + max) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F;如果目标值 &gt; 中间下标的中间值</span><br><span class="line">        if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">            &#x2F;&#x2F;最小变为中间下标+1</span><br><span class="line">            min &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果目标值 &lt; 中间下标的中间值</span><br><span class="line">        else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">            &#x2F;&#x2F;最大变为中间下标-1</span><br><span class="line">            max &#x3D; max - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则，正好</span><br><span class="line">        else &#123;</span><br><span class="line">            NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>8.哈希算法<br>通过哈希表查找，例如：查找”abaccdeff”中b字符的出现次数，每个字母根据其 ASCII 码值作为数组下标对应数组种的一个数字。数组中存储的是每个字符出现的次数。</p>
<p>9.给定一个整数数组，nums和一个目标值target ,请在数组中找出何为目标值的两个整数，并返回下标：<br>举例：给定num = @[2,3,9,12],target = 15;<br>     因为给定的nums[1] + nums[3] = 3+12 = 15<br>     所以返回[1,3];</p>
<p>思路一：暴力破解法，两层循环，第一层从初始位置进行遍历，第二次遍历第一层之后数组元素，找到两数之和为目标值并输出位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr &#x3D; @[@2,@3,@9,@12];</span><br><span class="line">    NSInteger target &#x3D; 15;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.count; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;第一层循环从初始位置开始</span><br><span class="line">        for (int j &#x3D; i+1;j&lt;arr.count ; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历i后面值，找到i,j位置和为目标值，并输出i,j位置</span><br><span class="line">            if ([arr[j] intValue] &#x3D;&#x3D; target - [arr[i] intValue]) &#123;</span><br><span class="line">                NSLog(@&quot;位置分别为： %d----%d&quot;,i,j);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line">思路二：</span><br><span class="line">* 先循环遍历数组：保存一个字典：使用字典进行keyValue形式保存数组，key为值，value为位置</span><br><span class="line">* 再次循环数组，直接计算出需要找到的值，然后判断字典中key是否存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 思路：<br> 1.先循环遍历数组：保存一个字典：<br> 使用字典进行keyValue形式保存数组，key为值，value为位置，<br> 2.再次循环数组，直接计算出需要找到的值，然后判断字典中key是否存在<br> 时间复杂度为O(n)<br> NSMutableDictionary * dic = [NSMutableDictionary dictionaryWithCapacity:arr.count];<br>//先遍历生成字典，key为值，value为位置<br>for (NSInteger i = 0; i &lt; arr.count; i ++) {<br>    [dic setObject:@(i) forKey:arr[i]];<br>}<br>//再遍历数组取差值<br>for (NSInteger i = 0; i &lt; arr.count; i ++) {<br>    //取差值<br>    NSInteger dif = target - [arr[i] integerValue];<br>    //如果字典有这个值<br>    if ([dic.allKeys containsObject:@(dif)]) {<br>        NSNumber * value = [dic objectForKey:@(dif)];<br>        NSLog(@”%ld – %ld”,i,[value integerValue]);<br>    }</p>
<p>}<br>```</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:13718004742@163.com">小J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.bboyzj.cn/2020/07/10/iOS-OC%E4%B9%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">https://www.bboyzj.cn/2020/07/10/iOS-OC%E4%B9%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.bboyzj.cn" target="_blank">张建的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/13718004742.github.io/tags/iOS-OC/">iOS-OC</a></div><div class="post_share"><div class="social-share" data-image="https://user-images.githubusercontent.com/25925248/89222506-be0f2480-d607-11ea-823f-aed914e3b27e.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/13718004742.github.io/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/13718004742.github.io/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/13718004742.github.io/2020/07/11/iOS-OC%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8Clang%E5%92%8CLLVM%E6%8E%A2%E7%B4%A2/"><img class="prev-cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89294514-33bfd280-d692-11ea-9151-7808205ed301.jpg" onerror="onerror=null;src='/13718004742.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">iOS-OC之编译器Clang和LLVM探索</div></div></a></div><div class="next-post pull-right"><a href="/13718004742.github.io/2020/07/09/iOS-OC%E4%B9%8BHTTP%E5%92%8CHTTPS%E5%92%8CSocket%E6%8E%A2%E7%B4%A2/"><img class="next-cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89222564-d717d580-d607-11ea-9f09-74358da90718.jpg" onerror="onerror=null;src='/13718004742.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">iOS-OC之HTTP和HTTPS和Socket探索</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/13718004742.github.io/2020/07/26/iOS-OC之Block底层探索/" title="iOS-OC之Block底层探索"><img class="relatedPosts_cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89219510-7cc84600-d602-11ea-9110-6b415b3c39bf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-26</div><div class="relatedPosts_title">iOS-OC之Block底层探索</div></div></a></div><div class="relatedPosts_item"><a href="/13718004742.github.io/2020/07/08/iOS-OC之MVC和MVVM探索/" title="iOS-OC之MVC和MVVM探索"><img class="relatedPosts_cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89218638-feb76f80-d600-11ea-88ac-c0f6fea6ee52.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="relatedPosts_title">iOS-OC之MVC和MVVM探索</div></div></a></div><div class="relatedPosts_item"><a href="/13718004742.github.io/2020/07/29/iOS-OC之Runloop底层原理/" title="iOS-OC之Runloop底层原理"><img class="relatedPosts_cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89219510-7cc84600-d602-11ea-9110-6b415b3c39bf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-29</div><div class="relatedPosts_title">iOS-OC之Runloop底层原理</div></div></a></div><div class="relatedPosts_item"><a href="/13718004742.github.io/2020/07/05/iOS-OC之UIView的绘制和渲染流程和原理探究/" title="iOS-OC之UIView的绘制和渲染流程和原理探究"><img class="relatedPosts_cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89294514-33bfd280-d692-11ea-9151-7808205ed301.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="relatedPosts_title">iOS-OC之UIView的绘制和渲染流程和原理探究</div></div></a></div><div class="relatedPosts_item"><a href="/13718004742.github.io/2020/07/06/iOS-OC之UI掉帧、卡顿原因分析及优化原因分析及优化/" title="iOS-OC之UI掉帧、卡顿原因分析及优化原因分析及优化"><img class="relatedPosts_cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89218638-feb76f80-d600-11ea-88ac-c0f6fea6ee52.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-06</div><div class="relatedPosts_title">iOS-OC之UI掉帧、卡顿原因分析及优化原因分析及优化</div></div></a></div><div class="relatedPosts_item"><a href="/13718004742.github.io/2020/07/14/iOS-OC之对象的分类/" title="iOS-OC之对象的分类"><img class="relatedPosts_cover" data-lazy-src="https://user-images.githubusercontent.com/25925248/89219769-f829f780-d602-11ea-96a1-e38c6eb5ba22.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-14</div><div class="relatedPosts_title">iOS-OC之对象的分类</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://user-images.githubusercontent.com/25925248/89222506-be0f2480-d607-11ea-823f-aed914e3b27e.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小J</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://www.bboyzj.top/">Hi, welcome to my blog!</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/13718004742.github.io/js/utils.js"></script><script src="/13718004742.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/13718004742.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="/13718004742.github.io/js/third-party/click_heart.js" async="async"></script></div></body></html>